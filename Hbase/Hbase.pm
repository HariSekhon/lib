#
# Autogenerated by Thrift Compiler (0.12.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
use 5.10.0;
use strict;
use warnings;
use Thrift::Exception;
use Thrift::MessageType;
use Thrift::Type;

use Hbase::Types;


# HELPER FUNCTIONS AND STRUCTURES

package Hbase::Hbase_enableTable_args;
use base qw(Class::Accessor);
Hbase::Hbase_enableTable_args->mk_accessors( qw( tableName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_enableTable_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_enableTable_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_enableTable_result;
use base qw(Class::Accessor);
Hbase::Hbase_enableTable_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_enableTable_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_enableTable_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_disableTable_args;
use base qw(Class::Accessor);
Hbase::Hbase_disableTable_args->mk_accessors( qw( tableName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_disableTable_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_disableTable_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_disableTable_result;
use base qw(Class::Accessor);
Hbase::Hbase_disableTable_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_disableTable_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_disableTable_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_isTableEnabled_args;
use base qw(Class::Accessor);
Hbase::Hbase_isTableEnabled_args->mk_accessors( qw( tableName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_isTableEnabled_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_isTableEnabled_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_isTableEnabled_result;
use base qw(Class::Accessor);
Hbase::Hbase_isTableEnabled_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_isTableEnabled_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_isTableEnabled_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_compact_args;
use base qw(Class::Accessor);
Hbase::Hbase_compact_args->mk_accessors( qw( tableNameOrRegionName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableNameOrRegionName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableNameOrRegionName}) {
      $self->{tableNameOrRegionName} = $vals->{tableNameOrRegionName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_compact_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{tableNameOrRegionName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_compact_args');
  if (defined $self->{tableNameOrRegionName}) {
    $xfer += $output->writeFieldBegin('tableNameOrRegionName', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{tableNameOrRegionName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_compact_result;
use base qw(Class::Accessor);
Hbase::Hbase_compact_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_compact_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_compact_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_majorCompact_args;
use base qw(Class::Accessor);
Hbase::Hbase_majorCompact_args->mk_accessors( qw( tableNameOrRegionName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableNameOrRegionName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableNameOrRegionName}) {
      $self->{tableNameOrRegionName} = $vals->{tableNameOrRegionName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_majorCompact_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{tableNameOrRegionName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_majorCompact_args');
  if (defined $self->{tableNameOrRegionName}) {
    $xfer += $output->writeFieldBegin('tableNameOrRegionName', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{tableNameOrRegionName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_majorCompact_result;
use base qw(Class::Accessor);
Hbase::Hbase_majorCompact_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_majorCompact_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_majorCompact_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getTableNames_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getTableNames_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getTableNames_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getTableNames_result;
use base qw(Class::Accessor);
Hbase::Hbase_getTableNames_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getTableNames_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size44 = 0;
          $self->{success} = [];
          my $_etype47 = 0;
          $xfer += $input->readListBegin(\$_etype47, \$_size44);
          for (my $_i48 = 0; $_i48 < $_size44; ++$_i48)
          {
            my $elem49 = undef;
            $xfer += $input->readString(\$elem49);
            push(@{$self->{success}},$elem49);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getTableNames_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter50 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter50);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getColumnDescriptors_args;
use base qw(Class::Accessor);
Hbase::Hbase_getColumnDescriptors_args->mk_accessors( qw( tableName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getColumnDescriptors_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getColumnDescriptors_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getColumnDescriptors_result;
use base qw(Class::Accessor);
Hbase::Hbase_getColumnDescriptors_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getColumnDescriptors_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size51 = 0;
          $self->{success} = {};
          my $_ktype52 = 0;
          my $_vtype53 = 0;
          $xfer += $input->readMapBegin(\$_ktype52, \$_vtype53, \$_size51);
          for (my $_i55 = 0; $_i55 < $_size51; ++$_i55)
          {
            my $key56 = '';
            my $val57 = Hbase::ColumnDescriptor->new();
            $xfer += $input->readString(\$key56);
            $val57 = Hbase::ColumnDescriptor->new();
            $xfer += $val57->read($input);
            $self->{success}->{$key56} = $val57;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getColumnDescriptors_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRUCT, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter58,$viter59) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter58);
          $xfer += ${viter59}->write($output);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getTableRegions_args;
use base qw(Class::Accessor);
Hbase::Hbase_getTableRegions_args->mk_accessors( qw( tableName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getTableRegions_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getTableRegions_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getTableRegions_result;
use base qw(Class::Accessor);
Hbase::Hbase_getTableRegions_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getTableRegions_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size60 = 0;
          $self->{success} = [];
          my $_etype63 = 0;
          $xfer += $input->readListBegin(\$_etype63, \$_size60);
          for (my $_i64 = 0; $_i64 < $_size60; ++$_i64)
          {
            my $elem65 = undef;
            $elem65 = Hbase::TRegionInfo->new();
            $xfer += $elem65->read($input);
            push(@{$self->{success}},$elem65);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getTableRegions_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter66 (@{$self->{success}}) 
        {
          $xfer += ${iter66}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_createTable_args;
use base qw(Class::Accessor);
Hbase::Hbase_createTable_args->mk_accessors( qw( tableName columnFamilies ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{columnFamilies} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{columnFamilies}) {
      $self->{columnFamilies} = $vals->{columnFamilies};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_createTable_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size67 = 0;
          $self->{columnFamilies} = [];
          my $_etype70 = 0;
          $xfer += $input->readListBegin(\$_etype70, \$_size67);
          for (my $_i71 = 0; $_i71 < $_size67; ++$_i71)
          {
            my $elem72 = undef;
            $elem72 = Hbase::ColumnDescriptor->new();
            $xfer += $elem72->read($input);
            push(@{$self->{columnFamilies}},$elem72);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_createTable_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnFamilies}) {
    $xfer += $output->writeFieldBegin('columnFamilies', Thrift::TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{columnFamilies}}));
      {
        foreach my $iter73 (@{$self->{columnFamilies}}) 
        {
          $xfer += ${iter73}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_createTable_result;
use base qw(Class::Accessor);
Hbase::Hbase_createTable_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  $self->{ia} = undef;
  $self->{exist} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
    if (defined $vals->{ia}) {
      $self->{ia} = $vals->{ia};
    }
    if (defined $vals->{exist}) {
      $self->{exist} = $vals->{exist};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_createTable_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ia} = Hbase::IllegalArgument->new();
        $xfer += $self->{ia}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{exist} = Hbase::AlreadyExists->new();
        $xfer += $self->{exist}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_createTable_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ia}) {
    $xfer += $output->writeFieldBegin('ia', Thrift::TType::STRUCT, 2);
    $xfer += $self->{ia}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{exist}) {
    $xfer += $output->writeFieldBegin('exist', Thrift::TType::STRUCT, 3);
    $xfer += $self->{exist}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_deleteTable_args;
use base qw(Class::Accessor);
Hbase::Hbase_deleteTable_args->mk_accessors( qw( tableName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_deleteTable_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_deleteTable_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_deleteTable_result;
use base qw(Class::Accessor);
Hbase::Hbase_deleteTable_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_deleteTable_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_deleteTable_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_get_args;
use base qw(Class::Accessor);
Hbase::Hbase_get_args->mk_accessors( qw( tableName row column attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{column} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_get_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size74 = 0;
          $self->{attributes} = {};
          my $_ktype75 = 0;
          my $_vtype76 = 0;
          $xfer += $input->readMapBegin(\$_ktype75, \$_vtype76, \$_size74);
          for (my $_i78 = 0; $_i78 < $_size74; ++$_i78)
          {
            my $key79 = '';
            my $val80 = '';
            $xfer += $input->readString(\$key79);
            $xfer += $input->readString(\$val80);
            $self->{attributes}->{$key79} = $val80;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_get_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', Thrift::TType::STRING, 3);
    $xfer += $output->writeString($self->{column});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter81,$viter82) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter81);
          $xfer += $output->writeString($viter82);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_get_result;
use base qw(Class::Accessor);
Hbase::Hbase_get_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_get_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size83 = 0;
          $self->{success} = [];
          my $_etype86 = 0;
          $xfer += $input->readListBegin(\$_etype86, \$_size83);
          for (my $_i87 = 0; $_i87 < $_size83; ++$_i87)
          {
            my $elem88 = undef;
            $elem88 = Hbase::TCell->new();
            $xfer += $elem88->read($input);
            push(@{$self->{success}},$elem88);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_get_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter89 (@{$self->{success}}) 
        {
          $xfer += ${iter89}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getVer_args;
use base qw(Class::Accessor);
Hbase::Hbase_getVer_args->mk_accessors( qw( tableName row column numVersions attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{column} = undef;
  $self->{numVersions} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
    if (defined $vals->{numVersions}) {
      $self->{numVersions} = $vals->{numVersions};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getVer_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{numVersions});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size90 = 0;
          $self->{attributes} = {};
          my $_ktype91 = 0;
          my $_vtype92 = 0;
          $xfer += $input->readMapBegin(\$_ktype91, \$_vtype92, \$_size90);
          for (my $_i94 = 0; $_i94 < $_size90; ++$_i94)
          {
            my $key95 = '';
            my $val96 = '';
            $xfer += $input->readString(\$key95);
            $xfer += $input->readString(\$val96);
            $self->{attributes}->{$key95} = $val96;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getVer_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', Thrift::TType::STRING, 3);
    $xfer += $output->writeString($self->{column});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{numVersions}) {
    $xfer += $output->writeFieldBegin('numVersions', Thrift::TType::I32, 4);
    $xfer += $output->writeI32($self->{numVersions});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 5);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter97,$viter98) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter97);
          $xfer += $output->writeString($viter98);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getVer_result;
use base qw(Class::Accessor);
Hbase::Hbase_getVer_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getVer_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size99 = 0;
          $self->{success} = [];
          my $_etype102 = 0;
          $xfer += $input->readListBegin(\$_etype102, \$_size99);
          for (my $_i103 = 0; $_i103 < $_size99; ++$_i103)
          {
            my $elem104 = undef;
            $elem104 = Hbase::TCell->new();
            $xfer += $elem104->read($input);
            push(@{$self->{success}},$elem104);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getVer_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter105 (@{$self->{success}}) 
        {
          $xfer += ${iter105}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getVerTs_args;
use base qw(Class::Accessor);
Hbase::Hbase_getVerTs_args->mk_accessors( qw( tableName row column timestamp numVersions attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{column} = undef;
  $self->{timestamp} = undef;
  $self->{numVersions} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{numVersions}) {
      $self->{numVersions} = $vals->{numVersions};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getVerTs_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{numVersions});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size106 = 0;
          $self->{attributes} = {};
          my $_ktype107 = 0;
          my $_vtype108 = 0;
          $xfer += $input->readMapBegin(\$_ktype107, \$_vtype108, \$_size106);
          for (my $_i110 = 0; $_i110 < $_size106; ++$_i110)
          {
            my $key111 = '';
            my $val112 = '';
            $xfer += $input->readString(\$key111);
            $xfer += $input->readString(\$val112);
            $self->{attributes}->{$key111} = $val112;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getVerTs_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', Thrift::TType::STRING, 3);
    $xfer += $output->writeString($self->{column});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', Thrift::TType::I64, 4);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{numVersions}) {
    $xfer += $output->writeFieldBegin('numVersions', Thrift::TType::I32, 5);
    $xfer += $output->writeI32($self->{numVersions});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 6);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter113,$viter114) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter113);
          $xfer += $output->writeString($viter114);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getVerTs_result;
use base qw(Class::Accessor);
Hbase::Hbase_getVerTs_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getVerTs_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size115 = 0;
          $self->{success} = [];
          my $_etype118 = 0;
          $xfer += $input->readListBegin(\$_etype118, \$_size115);
          for (my $_i119 = 0; $_i119 < $_size115; ++$_i119)
          {
            my $elem120 = undef;
            $elem120 = Hbase::TCell->new();
            $xfer += $elem120->read($input);
            push(@{$self->{success}},$elem120);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getVerTs_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter121 (@{$self->{success}}) 
        {
          $xfer += ${iter121}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRow_args;
use base qw(Class::Accessor);
Hbase::Hbase_getRow_args->mk_accessors( qw( tableName row attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRow_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size122 = 0;
          $self->{attributes} = {};
          my $_ktype123 = 0;
          my $_vtype124 = 0;
          $xfer += $input->readMapBegin(\$_ktype123, \$_vtype124, \$_size122);
          for (my $_i126 = 0; $_i126 < $_size122; ++$_i126)
          {
            my $key127 = '';
            my $val128 = '';
            $xfer += $input->readString(\$key127);
            $xfer += $input->readString(\$val128);
            $self->{attributes}->{$key127} = $val128;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRow_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 3);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter129,$viter130) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter129);
          $xfer += $output->writeString($viter130);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRow_result;
use base qw(Class::Accessor);
Hbase::Hbase_getRow_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRow_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size131 = 0;
          $self->{success} = [];
          my $_etype134 = 0;
          $xfer += $input->readListBegin(\$_etype134, \$_size131);
          for (my $_i135 = 0; $_i135 < $_size131; ++$_i135)
          {
            my $elem136 = undef;
            $elem136 = Hbase::TRowResult->new();
            $xfer += $elem136->read($input);
            push(@{$self->{success}},$elem136);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRow_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter137 (@{$self->{success}}) 
        {
          $xfer += ${iter137}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRowWithColumns_args;
use base qw(Class::Accessor);
Hbase::Hbase_getRowWithColumns_args->mk_accessors( qw( tableName row columns attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{columns} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRowWithColumns_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size138 = 0;
          $self->{columns} = [];
          my $_etype141 = 0;
          $xfer += $input->readListBegin(\$_etype141, \$_size138);
          for (my $_i142 = 0; $_i142 < $_size138; ++$_i142)
          {
            my $elem143 = undef;
            $xfer += $input->readString(\$elem143);
            push(@{$self->{columns}},$elem143);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size144 = 0;
          $self->{attributes} = {};
          my $_ktype145 = 0;
          my $_vtype146 = 0;
          $xfer += $input->readMapBegin(\$_ktype145, \$_vtype146, \$_size144);
          for (my $_i148 = 0; $_i148 < $_size144; ++$_i148)
          {
            my $key149 = '';
            my $val150 = '';
            $xfer += $input->readString(\$key149);
            $xfer += $input->readString(\$val150);
            $self->{attributes}->{$key149} = $val150;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRowWithColumns_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', Thrift::TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{columns}}));
      {
        foreach my $iter151 (@{$self->{columns}}) 
        {
          $xfer += $output->writeString($iter151);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter152,$viter153) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter152);
          $xfer += $output->writeString($viter153);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRowWithColumns_result;
use base qw(Class::Accessor);
Hbase::Hbase_getRowWithColumns_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRowWithColumns_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size154 = 0;
          $self->{success} = [];
          my $_etype157 = 0;
          $xfer += $input->readListBegin(\$_etype157, \$_size154);
          for (my $_i158 = 0; $_i158 < $_size154; ++$_i158)
          {
            my $elem159 = undef;
            $elem159 = Hbase::TRowResult->new();
            $xfer += $elem159->read($input);
            push(@{$self->{success}},$elem159);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRowWithColumns_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter160 (@{$self->{success}}) 
        {
          $xfer += ${iter160}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRowTs_args;
use base qw(Class::Accessor);
Hbase::Hbase_getRowTs_args->mk_accessors( qw( tableName row timestamp attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{timestamp} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRowTs_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size161 = 0;
          $self->{attributes} = {};
          my $_ktype162 = 0;
          my $_vtype163 = 0;
          $xfer += $input->readMapBegin(\$_ktype162, \$_vtype163, \$_size161);
          for (my $_i165 = 0; $_i165 < $_size161; ++$_i165)
          {
            my $key166 = '';
            my $val167 = '';
            $xfer += $input->readString(\$key166);
            $xfer += $input->readString(\$val167);
            $self->{attributes}->{$key166} = $val167;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRowTs_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', Thrift::TType::I64, 3);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter168,$viter169) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter168);
          $xfer += $output->writeString($viter169);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRowTs_result;
use base qw(Class::Accessor);
Hbase::Hbase_getRowTs_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRowTs_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size170 = 0;
          $self->{success} = [];
          my $_etype173 = 0;
          $xfer += $input->readListBegin(\$_etype173, \$_size170);
          for (my $_i174 = 0; $_i174 < $_size170; ++$_i174)
          {
            my $elem175 = undef;
            $elem175 = Hbase::TRowResult->new();
            $xfer += $elem175->read($input);
            push(@{$self->{success}},$elem175);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRowTs_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter176 (@{$self->{success}}) 
        {
          $xfer += ${iter176}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRowWithColumnsTs_args;
use base qw(Class::Accessor);
Hbase::Hbase_getRowWithColumnsTs_args->mk_accessors( qw( tableName row columns timestamp attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{columns} = undef;
  $self->{timestamp} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRowWithColumnsTs_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size177 = 0;
          $self->{columns} = [];
          my $_etype180 = 0;
          $xfer += $input->readListBegin(\$_etype180, \$_size177);
          for (my $_i181 = 0; $_i181 < $_size177; ++$_i181)
          {
            my $elem182 = undef;
            $xfer += $input->readString(\$elem182);
            push(@{$self->{columns}},$elem182);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size183 = 0;
          $self->{attributes} = {};
          my $_ktype184 = 0;
          my $_vtype185 = 0;
          $xfer += $input->readMapBegin(\$_ktype184, \$_vtype185, \$_size183);
          for (my $_i187 = 0; $_i187 < $_size183; ++$_i187)
          {
            my $key188 = '';
            my $val189 = '';
            $xfer += $input->readString(\$key188);
            $xfer += $input->readString(\$val189);
            $self->{attributes}->{$key188} = $val189;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRowWithColumnsTs_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', Thrift::TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{columns}}));
      {
        foreach my $iter190 (@{$self->{columns}}) 
        {
          $xfer += $output->writeString($iter190);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', Thrift::TType::I64, 4);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 5);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter191,$viter192) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter191);
          $xfer += $output->writeString($viter192);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRowWithColumnsTs_result;
use base qw(Class::Accessor);
Hbase::Hbase_getRowWithColumnsTs_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRowWithColumnsTs_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size193 = 0;
          $self->{success} = [];
          my $_etype196 = 0;
          $xfer += $input->readListBegin(\$_etype196, \$_size193);
          for (my $_i197 = 0; $_i197 < $_size193; ++$_i197)
          {
            my $elem198 = undef;
            $elem198 = Hbase::TRowResult->new();
            $xfer += $elem198->read($input);
            push(@{$self->{success}},$elem198);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRowWithColumnsTs_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter199 (@{$self->{success}}) 
        {
          $xfer += ${iter199}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRows_args;
use base qw(Class::Accessor);
Hbase::Hbase_getRows_args->mk_accessors( qw( tableName rows attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{rows} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{rows}) {
      $self->{rows} = $vals->{rows};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRows_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size200 = 0;
          $self->{rows} = [];
          my $_etype203 = 0;
          $xfer += $input->readListBegin(\$_etype203, \$_size200);
          for (my $_i204 = 0; $_i204 < $_size200; ++$_i204)
          {
            my $elem205 = undef;
            $xfer += $input->readString(\$elem205);
            push(@{$self->{rows}},$elem205);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size206 = 0;
          $self->{attributes} = {};
          my $_ktype207 = 0;
          my $_vtype208 = 0;
          $xfer += $input->readMapBegin(\$_ktype207, \$_vtype208, \$_size206);
          for (my $_i210 = 0; $_i210 < $_size206; ++$_i210)
          {
            my $key211 = '';
            my $val212 = '';
            $xfer += $input->readString(\$key211);
            $xfer += $input->readString(\$val212);
            $self->{attributes}->{$key211} = $val212;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRows_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rows}) {
    $xfer += $output->writeFieldBegin('rows', Thrift::TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{rows}}));
      {
        foreach my $iter213 (@{$self->{rows}}) 
        {
          $xfer += $output->writeString($iter213);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 3);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter214,$viter215) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter214);
          $xfer += $output->writeString($viter215);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRows_result;
use base qw(Class::Accessor);
Hbase::Hbase_getRows_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRows_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size216 = 0;
          $self->{success} = [];
          my $_etype219 = 0;
          $xfer += $input->readListBegin(\$_etype219, \$_size216);
          for (my $_i220 = 0; $_i220 < $_size216; ++$_i220)
          {
            my $elem221 = undef;
            $elem221 = Hbase::TRowResult->new();
            $xfer += $elem221->read($input);
            push(@{$self->{success}},$elem221);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRows_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter222 (@{$self->{success}}) 
        {
          $xfer += ${iter222}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRowsWithColumns_args;
use base qw(Class::Accessor);
Hbase::Hbase_getRowsWithColumns_args->mk_accessors( qw( tableName rows columns attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{rows} = undef;
  $self->{columns} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{rows}) {
      $self->{rows} = $vals->{rows};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRowsWithColumns_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size223 = 0;
          $self->{rows} = [];
          my $_etype226 = 0;
          $xfer += $input->readListBegin(\$_etype226, \$_size223);
          for (my $_i227 = 0; $_i227 < $_size223; ++$_i227)
          {
            my $elem228 = undef;
            $xfer += $input->readString(\$elem228);
            push(@{$self->{rows}},$elem228);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size229 = 0;
          $self->{columns} = [];
          my $_etype232 = 0;
          $xfer += $input->readListBegin(\$_etype232, \$_size229);
          for (my $_i233 = 0; $_i233 < $_size229; ++$_i233)
          {
            my $elem234 = undef;
            $xfer += $input->readString(\$elem234);
            push(@{$self->{columns}},$elem234);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size235 = 0;
          $self->{attributes} = {};
          my $_ktype236 = 0;
          my $_vtype237 = 0;
          $xfer += $input->readMapBegin(\$_ktype236, \$_vtype237, \$_size235);
          for (my $_i239 = 0; $_i239 < $_size235; ++$_i239)
          {
            my $key240 = '';
            my $val241 = '';
            $xfer += $input->readString(\$key240);
            $xfer += $input->readString(\$val241);
            $self->{attributes}->{$key240} = $val241;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRowsWithColumns_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rows}) {
    $xfer += $output->writeFieldBegin('rows', Thrift::TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{rows}}));
      {
        foreach my $iter242 (@{$self->{rows}}) 
        {
          $xfer += $output->writeString($iter242);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', Thrift::TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{columns}}));
      {
        foreach my $iter243 (@{$self->{columns}}) 
        {
          $xfer += $output->writeString($iter243);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter244,$viter245) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter244);
          $xfer += $output->writeString($viter245);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRowsWithColumns_result;
use base qw(Class::Accessor);
Hbase::Hbase_getRowsWithColumns_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRowsWithColumns_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size246 = 0;
          $self->{success} = [];
          my $_etype249 = 0;
          $xfer += $input->readListBegin(\$_etype249, \$_size246);
          for (my $_i250 = 0; $_i250 < $_size246; ++$_i250)
          {
            my $elem251 = undef;
            $elem251 = Hbase::TRowResult->new();
            $xfer += $elem251->read($input);
            push(@{$self->{success}},$elem251);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRowsWithColumns_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter252 (@{$self->{success}}) 
        {
          $xfer += ${iter252}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRowsTs_args;
use base qw(Class::Accessor);
Hbase::Hbase_getRowsTs_args->mk_accessors( qw( tableName rows timestamp attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{rows} = undef;
  $self->{timestamp} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{rows}) {
      $self->{rows} = $vals->{rows};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRowsTs_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size253 = 0;
          $self->{rows} = [];
          my $_etype256 = 0;
          $xfer += $input->readListBegin(\$_etype256, \$_size253);
          for (my $_i257 = 0; $_i257 < $_size253; ++$_i257)
          {
            my $elem258 = undef;
            $xfer += $input->readString(\$elem258);
            push(@{$self->{rows}},$elem258);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size259 = 0;
          $self->{attributes} = {};
          my $_ktype260 = 0;
          my $_vtype261 = 0;
          $xfer += $input->readMapBegin(\$_ktype260, \$_vtype261, \$_size259);
          for (my $_i263 = 0; $_i263 < $_size259; ++$_i263)
          {
            my $key264 = '';
            my $val265 = '';
            $xfer += $input->readString(\$key264);
            $xfer += $input->readString(\$val265);
            $self->{attributes}->{$key264} = $val265;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRowsTs_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rows}) {
    $xfer += $output->writeFieldBegin('rows', Thrift::TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{rows}}));
      {
        foreach my $iter266 (@{$self->{rows}}) 
        {
          $xfer += $output->writeString($iter266);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', Thrift::TType::I64, 3);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter267,$viter268) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter267);
          $xfer += $output->writeString($viter268);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRowsTs_result;
use base qw(Class::Accessor);
Hbase::Hbase_getRowsTs_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRowsTs_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size269 = 0;
          $self->{success} = [];
          my $_etype272 = 0;
          $xfer += $input->readListBegin(\$_etype272, \$_size269);
          for (my $_i273 = 0; $_i273 < $_size269; ++$_i273)
          {
            my $elem274 = undef;
            $elem274 = Hbase::TRowResult->new();
            $xfer += $elem274->read($input);
            push(@{$self->{success}},$elem274);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRowsTs_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter275 (@{$self->{success}}) 
        {
          $xfer += ${iter275}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRowsWithColumnsTs_args;
use base qw(Class::Accessor);
Hbase::Hbase_getRowsWithColumnsTs_args->mk_accessors( qw( tableName rows columns timestamp attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{rows} = undef;
  $self->{columns} = undef;
  $self->{timestamp} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{rows}) {
      $self->{rows} = $vals->{rows};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRowsWithColumnsTs_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size276 = 0;
          $self->{rows} = [];
          my $_etype279 = 0;
          $xfer += $input->readListBegin(\$_etype279, \$_size276);
          for (my $_i280 = 0; $_i280 < $_size276; ++$_i280)
          {
            my $elem281 = undef;
            $xfer += $input->readString(\$elem281);
            push(@{$self->{rows}},$elem281);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size282 = 0;
          $self->{columns} = [];
          my $_etype285 = 0;
          $xfer += $input->readListBegin(\$_etype285, \$_size282);
          for (my $_i286 = 0; $_i286 < $_size282; ++$_i286)
          {
            my $elem287 = undef;
            $xfer += $input->readString(\$elem287);
            push(@{$self->{columns}},$elem287);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size288 = 0;
          $self->{attributes} = {};
          my $_ktype289 = 0;
          my $_vtype290 = 0;
          $xfer += $input->readMapBegin(\$_ktype289, \$_vtype290, \$_size288);
          for (my $_i292 = 0; $_i292 < $_size288; ++$_i292)
          {
            my $key293 = '';
            my $val294 = '';
            $xfer += $input->readString(\$key293);
            $xfer += $input->readString(\$val294);
            $self->{attributes}->{$key293} = $val294;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRowsWithColumnsTs_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rows}) {
    $xfer += $output->writeFieldBegin('rows', Thrift::TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{rows}}));
      {
        foreach my $iter295 (@{$self->{rows}}) 
        {
          $xfer += $output->writeString($iter295);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', Thrift::TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{columns}}));
      {
        foreach my $iter296 (@{$self->{columns}}) 
        {
          $xfer += $output->writeString($iter296);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', Thrift::TType::I64, 4);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 5);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter297,$viter298) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter297);
          $xfer += $output->writeString($viter298);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRowsWithColumnsTs_result;
use base qw(Class::Accessor);
Hbase::Hbase_getRowsWithColumnsTs_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRowsWithColumnsTs_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size299 = 0;
          $self->{success} = [];
          my $_etype302 = 0;
          $xfer += $input->readListBegin(\$_etype302, \$_size299);
          for (my $_i303 = 0; $_i303 < $_size299; ++$_i303)
          {
            my $elem304 = undef;
            $elem304 = Hbase::TRowResult->new();
            $xfer += $elem304->read($input);
            push(@{$self->{success}},$elem304);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRowsWithColumnsTs_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter305 (@{$self->{success}}) 
        {
          $xfer += ${iter305}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_mutateRow_args;
use base qw(Class::Accessor);
Hbase::Hbase_mutateRow_args->mk_accessors( qw( tableName row mutations attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{mutations} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{mutations}) {
      $self->{mutations} = $vals->{mutations};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_mutateRow_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size306 = 0;
          $self->{mutations} = [];
          my $_etype309 = 0;
          $xfer += $input->readListBegin(\$_etype309, \$_size306);
          for (my $_i310 = 0; $_i310 < $_size306; ++$_i310)
          {
            my $elem311 = undef;
            $elem311 = Hbase::Mutation->new();
            $xfer += $elem311->read($input);
            push(@{$self->{mutations}},$elem311);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size312 = 0;
          $self->{attributes} = {};
          my $_ktype313 = 0;
          my $_vtype314 = 0;
          $xfer += $input->readMapBegin(\$_ktype313, \$_vtype314, \$_size312);
          for (my $_i316 = 0; $_i316 < $_size312; ++$_i316)
          {
            my $key317 = '';
            my $val318 = '';
            $xfer += $input->readString(\$key317);
            $xfer += $input->readString(\$val318);
            $self->{attributes}->{$key317} = $val318;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_mutateRow_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mutations}) {
    $xfer += $output->writeFieldBegin('mutations', Thrift::TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{mutations}}));
      {
        foreach my $iter319 (@{$self->{mutations}}) 
        {
          $xfer += ${iter319}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter320,$viter321) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter320);
          $xfer += $output->writeString($viter321);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_mutateRow_result;
use base qw(Class::Accessor);
Hbase::Hbase_mutateRow_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  $self->{ia} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
    if (defined $vals->{ia}) {
      $self->{ia} = $vals->{ia};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_mutateRow_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ia} = Hbase::IllegalArgument->new();
        $xfer += $self->{ia}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_mutateRow_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ia}) {
    $xfer += $output->writeFieldBegin('ia', Thrift::TType::STRUCT, 2);
    $xfer += $self->{ia}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_mutateRowTs_args;
use base qw(Class::Accessor);
Hbase::Hbase_mutateRowTs_args->mk_accessors( qw( tableName row mutations timestamp attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{mutations} = undef;
  $self->{timestamp} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{mutations}) {
      $self->{mutations} = $vals->{mutations};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_mutateRowTs_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size322 = 0;
          $self->{mutations} = [];
          my $_etype325 = 0;
          $xfer += $input->readListBegin(\$_etype325, \$_size322);
          for (my $_i326 = 0; $_i326 < $_size322; ++$_i326)
          {
            my $elem327 = undef;
            $elem327 = Hbase::Mutation->new();
            $xfer += $elem327->read($input);
            push(@{$self->{mutations}},$elem327);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size328 = 0;
          $self->{attributes} = {};
          my $_ktype329 = 0;
          my $_vtype330 = 0;
          $xfer += $input->readMapBegin(\$_ktype329, \$_vtype330, \$_size328);
          for (my $_i332 = 0; $_i332 < $_size328; ++$_i332)
          {
            my $key333 = '';
            my $val334 = '';
            $xfer += $input->readString(\$key333);
            $xfer += $input->readString(\$val334);
            $self->{attributes}->{$key333} = $val334;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_mutateRowTs_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mutations}) {
    $xfer += $output->writeFieldBegin('mutations', Thrift::TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{mutations}}));
      {
        foreach my $iter335 (@{$self->{mutations}}) 
        {
          $xfer += ${iter335}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', Thrift::TType::I64, 4);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 5);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter336,$viter337) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter336);
          $xfer += $output->writeString($viter337);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_mutateRowTs_result;
use base qw(Class::Accessor);
Hbase::Hbase_mutateRowTs_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  $self->{ia} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
    if (defined $vals->{ia}) {
      $self->{ia} = $vals->{ia};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_mutateRowTs_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ia} = Hbase::IllegalArgument->new();
        $xfer += $self->{ia}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_mutateRowTs_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ia}) {
    $xfer += $output->writeFieldBegin('ia', Thrift::TType::STRUCT, 2);
    $xfer += $self->{ia}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_mutateRows_args;
use base qw(Class::Accessor);
Hbase::Hbase_mutateRows_args->mk_accessors( qw( tableName rowBatches attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{rowBatches} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{rowBatches}) {
      $self->{rowBatches} = $vals->{rowBatches};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_mutateRows_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size338 = 0;
          $self->{rowBatches} = [];
          my $_etype341 = 0;
          $xfer += $input->readListBegin(\$_etype341, \$_size338);
          for (my $_i342 = 0; $_i342 < $_size338; ++$_i342)
          {
            my $elem343 = undef;
            $elem343 = Hbase::BatchMutation->new();
            $xfer += $elem343->read($input);
            push(@{$self->{rowBatches}},$elem343);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size344 = 0;
          $self->{attributes} = {};
          my $_ktype345 = 0;
          my $_vtype346 = 0;
          $xfer += $input->readMapBegin(\$_ktype345, \$_vtype346, \$_size344);
          for (my $_i348 = 0; $_i348 < $_size344; ++$_i348)
          {
            my $key349 = '';
            my $val350 = '';
            $xfer += $input->readString(\$key349);
            $xfer += $input->readString(\$val350);
            $self->{attributes}->{$key349} = $val350;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_mutateRows_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rowBatches}) {
    $xfer += $output->writeFieldBegin('rowBatches', Thrift::TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{rowBatches}}));
      {
        foreach my $iter351 (@{$self->{rowBatches}}) 
        {
          $xfer += ${iter351}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 3);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter352,$viter353) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter352);
          $xfer += $output->writeString($viter353);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_mutateRows_result;
use base qw(Class::Accessor);
Hbase::Hbase_mutateRows_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  $self->{ia} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
    if (defined $vals->{ia}) {
      $self->{ia} = $vals->{ia};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_mutateRows_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ia} = Hbase::IllegalArgument->new();
        $xfer += $self->{ia}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_mutateRows_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ia}) {
    $xfer += $output->writeFieldBegin('ia', Thrift::TType::STRUCT, 2);
    $xfer += $self->{ia}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_mutateRowsTs_args;
use base qw(Class::Accessor);
Hbase::Hbase_mutateRowsTs_args->mk_accessors( qw( tableName rowBatches timestamp attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{rowBatches} = undef;
  $self->{timestamp} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{rowBatches}) {
      $self->{rowBatches} = $vals->{rowBatches};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_mutateRowsTs_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size354 = 0;
          $self->{rowBatches} = [];
          my $_etype357 = 0;
          $xfer += $input->readListBegin(\$_etype357, \$_size354);
          for (my $_i358 = 0; $_i358 < $_size354; ++$_i358)
          {
            my $elem359 = undef;
            $elem359 = Hbase::BatchMutation->new();
            $xfer += $elem359->read($input);
            push(@{$self->{rowBatches}},$elem359);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size360 = 0;
          $self->{attributes} = {};
          my $_ktype361 = 0;
          my $_vtype362 = 0;
          $xfer += $input->readMapBegin(\$_ktype361, \$_vtype362, \$_size360);
          for (my $_i364 = 0; $_i364 < $_size360; ++$_i364)
          {
            my $key365 = '';
            my $val366 = '';
            $xfer += $input->readString(\$key365);
            $xfer += $input->readString(\$val366);
            $self->{attributes}->{$key365} = $val366;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_mutateRowsTs_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rowBatches}) {
    $xfer += $output->writeFieldBegin('rowBatches', Thrift::TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{rowBatches}}));
      {
        foreach my $iter367 (@{$self->{rowBatches}}) 
        {
          $xfer += ${iter367}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', Thrift::TType::I64, 3);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter368,$viter369) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter368);
          $xfer += $output->writeString($viter369);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_mutateRowsTs_result;
use base qw(Class::Accessor);
Hbase::Hbase_mutateRowsTs_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  $self->{ia} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
    if (defined $vals->{ia}) {
      $self->{ia} = $vals->{ia};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_mutateRowsTs_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ia} = Hbase::IllegalArgument->new();
        $xfer += $self->{ia}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_mutateRowsTs_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ia}) {
    $xfer += $output->writeFieldBegin('ia', Thrift::TType::STRUCT, 2);
    $xfer += $self->{ia}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_atomicIncrement_args;
use base qw(Class::Accessor);
Hbase::Hbase_atomicIncrement_args->mk_accessors( qw( tableName row column value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{column} = undef;
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_atomicIncrement_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_atomicIncrement_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', Thrift::TType::STRING, 3);
    $xfer += $output->writeString($self->{column});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', Thrift::TType::I64, 4);
    $xfer += $output->writeI64($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_atomicIncrement_result;
use base qw(Class::Accessor);
Hbase::Hbase_atomicIncrement_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  $self->{ia} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
    if (defined $vals->{ia}) {
      $self->{ia} = $vals->{ia};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_atomicIncrement_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ia} = Hbase::IllegalArgument->new();
        $xfer += $self->{ia}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_atomicIncrement_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ia}) {
    $xfer += $output->writeFieldBegin('ia', Thrift::TType::STRUCT, 2);
    $xfer += $self->{ia}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_deleteAll_args;
use base qw(Class::Accessor);
Hbase::Hbase_deleteAll_args->mk_accessors( qw( tableName row column attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{column} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_deleteAll_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size370 = 0;
          $self->{attributes} = {};
          my $_ktype371 = 0;
          my $_vtype372 = 0;
          $xfer += $input->readMapBegin(\$_ktype371, \$_vtype372, \$_size370);
          for (my $_i374 = 0; $_i374 < $_size370; ++$_i374)
          {
            my $key375 = '';
            my $val376 = '';
            $xfer += $input->readString(\$key375);
            $xfer += $input->readString(\$val376);
            $self->{attributes}->{$key375} = $val376;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_deleteAll_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', Thrift::TType::STRING, 3);
    $xfer += $output->writeString($self->{column});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter377,$viter378) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter377);
          $xfer += $output->writeString($viter378);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_deleteAll_result;
use base qw(Class::Accessor);
Hbase::Hbase_deleteAll_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_deleteAll_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_deleteAll_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_deleteAllTs_args;
use base qw(Class::Accessor);
Hbase::Hbase_deleteAllTs_args->mk_accessors( qw( tableName row column timestamp attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{column} = undef;
  $self->{timestamp} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_deleteAllTs_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size379 = 0;
          $self->{attributes} = {};
          my $_ktype380 = 0;
          my $_vtype381 = 0;
          $xfer += $input->readMapBegin(\$_ktype380, \$_vtype381, \$_size379);
          for (my $_i383 = 0; $_i383 < $_size379; ++$_i383)
          {
            my $key384 = '';
            my $val385 = '';
            $xfer += $input->readString(\$key384);
            $xfer += $input->readString(\$val385);
            $self->{attributes}->{$key384} = $val385;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_deleteAllTs_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', Thrift::TType::STRING, 3);
    $xfer += $output->writeString($self->{column});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', Thrift::TType::I64, 4);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 5);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter386,$viter387) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter386);
          $xfer += $output->writeString($viter387);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_deleteAllTs_result;
use base qw(Class::Accessor);
Hbase::Hbase_deleteAllTs_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_deleteAllTs_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_deleteAllTs_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_deleteAllRow_args;
use base qw(Class::Accessor);
Hbase::Hbase_deleteAllRow_args->mk_accessors( qw( tableName row attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_deleteAllRow_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size388 = 0;
          $self->{attributes} = {};
          my $_ktype389 = 0;
          my $_vtype390 = 0;
          $xfer += $input->readMapBegin(\$_ktype389, \$_vtype390, \$_size388);
          for (my $_i392 = 0; $_i392 < $_size388; ++$_i392)
          {
            my $key393 = '';
            my $val394 = '';
            $xfer += $input->readString(\$key393);
            $xfer += $input->readString(\$val394);
            $self->{attributes}->{$key393} = $val394;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_deleteAllRow_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 3);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter395,$viter396) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter395);
          $xfer += $output->writeString($viter396);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_deleteAllRow_result;
use base qw(Class::Accessor);
Hbase::Hbase_deleteAllRow_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_deleteAllRow_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_deleteAllRow_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_increment_args;
use base qw(Class::Accessor);
Hbase::Hbase_increment_args->mk_accessors( qw( increment ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{increment} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{increment}) {
      $self->{increment} = $vals->{increment};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_increment_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{increment} = Hbase::TIncrement->new();
        $xfer += $self->{increment}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_increment_args');
  if (defined $self->{increment}) {
    $xfer += $output->writeFieldBegin('increment', Thrift::TType::STRUCT, 1);
    $xfer += $self->{increment}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_increment_result;
use base qw(Class::Accessor);
Hbase::Hbase_increment_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_increment_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_increment_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_incrementRows_args;
use base qw(Class::Accessor);
Hbase::Hbase_incrementRows_args->mk_accessors( qw( increments ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{increments} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{increments}) {
      $self->{increments} = $vals->{increments};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_incrementRows_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size397 = 0;
          $self->{increments} = [];
          my $_etype400 = 0;
          $xfer += $input->readListBegin(\$_etype400, \$_size397);
          for (my $_i401 = 0; $_i401 < $_size397; ++$_i401)
          {
            my $elem402 = undef;
            $elem402 = Hbase::TIncrement->new();
            $xfer += $elem402->read($input);
            push(@{$self->{increments}},$elem402);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_incrementRows_args');
  if (defined $self->{increments}) {
    $xfer += $output->writeFieldBegin('increments', Thrift::TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{increments}}));
      {
        foreach my $iter403 (@{$self->{increments}}) 
        {
          $xfer += ${iter403}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_incrementRows_result;
use base qw(Class::Accessor);
Hbase::Hbase_incrementRows_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_incrementRows_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_incrementRows_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_deleteAllRowTs_args;
use base qw(Class::Accessor);
Hbase::Hbase_deleteAllRowTs_args->mk_accessors( qw( tableName row timestamp attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{timestamp} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_deleteAllRowTs_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size404 = 0;
          $self->{attributes} = {};
          my $_ktype405 = 0;
          my $_vtype406 = 0;
          $xfer += $input->readMapBegin(\$_ktype405, \$_vtype406, \$_size404);
          for (my $_i408 = 0; $_i408 < $_size404; ++$_i408)
          {
            my $key409 = '';
            my $val410 = '';
            $xfer += $input->readString(\$key409);
            $xfer += $input->readString(\$val410);
            $self->{attributes}->{$key409} = $val410;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_deleteAllRowTs_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', Thrift::TType::I64, 3);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter411,$viter412) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter411);
          $xfer += $output->writeString($viter412);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_deleteAllRowTs_result;
use base qw(Class::Accessor);
Hbase::Hbase_deleteAllRowTs_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_deleteAllRowTs_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_deleteAllRowTs_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerOpenWithScan_args;
use base qw(Class::Accessor);
Hbase::Hbase_scannerOpenWithScan_args->mk_accessors( qw( tableName scan attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{scan} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{scan}) {
      $self->{scan} = $vals->{scan};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerOpenWithScan_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{scan} = Hbase::TScan->new();
        $xfer += $self->{scan}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size413 = 0;
          $self->{attributes} = {};
          my $_ktype414 = 0;
          my $_vtype415 = 0;
          $xfer += $input->readMapBegin(\$_ktype414, \$_vtype415, \$_size413);
          for (my $_i417 = 0; $_i417 < $_size413; ++$_i417)
          {
            my $key418 = '';
            my $val419 = '';
            $xfer += $input->readString(\$key418);
            $xfer += $input->readString(\$val419);
            $self->{attributes}->{$key418} = $val419;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerOpenWithScan_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{scan}) {
    $xfer += $output->writeFieldBegin('scan', Thrift::TType::STRUCT, 2);
    $xfer += $self->{scan}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 3);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter420,$viter421) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter420);
          $xfer += $output->writeString($viter421);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerOpenWithScan_result;
use base qw(Class::Accessor);
Hbase::Hbase_scannerOpenWithScan_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerOpenWithScan_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerOpenWithScan_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerOpen_args;
use base qw(Class::Accessor);
Hbase::Hbase_scannerOpen_args->mk_accessors( qw( tableName startRow columns attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{startRow} = undef;
  $self->{columns} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{startRow}) {
      $self->{startRow} = $vals->{startRow};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerOpen_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{startRow});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size422 = 0;
          $self->{columns} = [];
          my $_etype425 = 0;
          $xfer += $input->readListBegin(\$_etype425, \$_size422);
          for (my $_i426 = 0; $_i426 < $_size422; ++$_i426)
          {
            my $elem427 = undef;
            $xfer += $input->readString(\$elem427);
            push(@{$self->{columns}},$elem427);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size428 = 0;
          $self->{attributes} = {};
          my $_ktype429 = 0;
          my $_vtype430 = 0;
          $xfer += $input->readMapBegin(\$_ktype429, \$_vtype430, \$_size428);
          for (my $_i432 = 0; $_i432 < $_size428; ++$_i432)
          {
            my $key433 = '';
            my $val434 = '';
            $xfer += $input->readString(\$key433);
            $xfer += $input->readString(\$val434);
            $self->{attributes}->{$key433} = $val434;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerOpen_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{startRow}) {
    $xfer += $output->writeFieldBegin('startRow', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{startRow});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', Thrift::TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{columns}}));
      {
        foreach my $iter435 (@{$self->{columns}}) 
        {
          $xfer += $output->writeString($iter435);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter436,$viter437) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter436);
          $xfer += $output->writeString($viter437);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerOpen_result;
use base qw(Class::Accessor);
Hbase::Hbase_scannerOpen_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerOpen_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerOpen_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerOpenWithStop_args;
use base qw(Class::Accessor);
Hbase::Hbase_scannerOpenWithStop_args->mk_accessors( qw( tableName startRow stopRow columns attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{startRow} = undef;
  $self->{stopRow} = undef;
  $self->{columns} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{startRow}) {
      $self->{startRow} = $vals->{startRow};
    }
    if (defined $vals->{stopRow}) {
      $self->{stopRow} = $vals->{stopRow};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerOpenWithStop_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{startRow});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{stopRow});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size438 = 0;
          $self->{columns} = [];
          my $_etype441 = 0;
          $xfer += $input->readListBegin(\$_etype441, \$_size438);
          for (my $_i442 = 0; $_i442 < $_size438; ++$_i442)
          {
            my $elem443 = undef;
            $xfer += $input->readString(\$elem443);
            push(@{$self->{columns}},$elem443);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size444 = 0;
          $self->{attributes} = {};
          my $_ktype445 = 0;
          my $_vtype446 = 0;
          $xfer += $input->readMapBegin(\$_ktype445, \$_vtype446, \$_size444);
          for (my $_i448 = 0; $_i448 < $_size444; ++$_i448)
          {
            my $key449 = '';
            my $val450 = '';
            $xfer += $input->readString(\$key449);
            $xfer += $input->readString(\$val450);
            $self->{attributes}->{$key449} = $val450;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerOpenWithStop_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{startRow}) {
    $xfer += $output->writeFieldBegin('startRow', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{startRow});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{stopRow}) {
    $xfer += $output->writeFieldBegin('stopRow', Thrift::TType::STRING, 3);
    $xfer += $output->writeString($self->{stopRow});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', Thrift::TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{columns}}));
      {
        foreach my $iter451 (@{$self->{columns}}) 
        {
          $xfer += $output->writeString($iter451);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 5);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter452,$viter453) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter452);
          $xfer += $output->writeString($viter453);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerOpenWithStop_result;
use base qw(Class::Accessor);
Hbase::Hbase_scannerOpenWithStop_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerOpenWithStop_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerOpenWithStop_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerOpenWithPrefix_args;
use base qw(Class::Accessor);
Hbase::Hbase_scannerOpenWithPrefix_args->mk_accessors( qw( tableName startAndPrefix columns attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{startAndPrefix} = undef;
  $self->{columns} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{startAndPrefix}) {
      $self->{startAndPrefix} = $vals->{startAndPrefix};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerOpenWithPrefix_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{startAndPrefix});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size454 = 0;
          $self->{columns} = [];
          my $_etype457 = 0;
          $xfer += $input->readListBegin(\$_etype457, \$_size454);
          for (my $_i458 = 0; $_i458 < $_size454; ++$_i458)
          {
            my $elem459 = undef;
            $xfer += $input->readString(\$elem459);
            push(@{$self->{columns}},$elem459);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size460 = 0;
          $self->{attributes} = {};
          my $_ktype461 = 0;
          my $_vtype462 = 0;
          $xfer += $input->readMapBegin(\$_ktype461, \$_vtype462, \$_size460);
          for (my $_i464 = 0; $_i464 < $_size460; ++$_i464)
          {
            my $key465 = '';
            my $val466 = '';
            $xfer += $input->readString(\$key465);
            $xfer += $input->readString(\$val466);
            $self->{attributes}->{$key465} = $val466;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerOpenWithPrefix_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{startAndPrefix}) {
    $xfer += $output->writeFieldBegin('startAndPrefix', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{startAndPrefix});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', Thrift::TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{columns}}));
      {
        foreach my $iter467 (@{$self->{columns}}) 
        {
          $xfer += $output->writeString($iter467);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter468,$viter469) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter468);
          $xfer += $output->writeString($viter469);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerOpenWithPrefix_result;
use base qw(Class::Accessor);
Hbase::Hbase_scannerOpenWithPrefix_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerOpenWithPrefix_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerOpenWithPrefix_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerOpenTs_args;
use base qw(Class::Accessor);
Hbase::Hbase_scannerOpenTs_args->mk_accessors( qw( tableName startRow columns timestamp attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{startRow} = undef;
  $self->{columns} = undef;
  $self->{timestamp} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{startRow}) {
      $self->{startRow} = $vals->{startRow};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerOpenTs_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{startRow});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size470 = 0;
          $self->{columns} = [];
          my $_etype473 = 0;
          $xfer += $input->readListBegin(\$_etype473, \$_size470);
          for (my $_i474 = 0; $_i474 < $_size470; ++$_i474)
          {
            my $elem475 = undef;
            $xfer += $input->readString(\$elem475);
            push(@{$self->{columns}},$elem475);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size476 = 0;
          $self->{attributes} = {};
          my $_ktype477 = 0;
          my $_vtype478 = 0;
          $xfer += $input->readMapBegin(\$_ktype477, \$_vtype478, \$_size476);
          for (my $_i480 = 0; $_i480 < $_size476; ++$_i480)
          {
            my $key481 = '';
            my $val482 = '';
            $xfer += $input->readString(\$key481);
            $xfer += $input->readString(\$val482);
            $self->{attributes}->{$key481} = $val482;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerOpenTs_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{startRow}) {
    $xfer += $output->writeFieldBegin('startRow', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{startRow});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', Thrift::TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{columns}}));
      {
        foreach my $iter483 (@{$self->{columns}}) 
        {
          $xfer += $output->writeString($iter483);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', Thrift::TType::I64, 4);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 5);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter484,$viter485) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter484);
          $xfer += $output->writeString($viter485);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerOpenTs_result;
use base qw(Class::Accessor);
Hbase::Hbase_scannerOpenTs_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerOpenTs_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerOpenTs_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerOpenWithStopTs_args;
use base qw(Class::Accessor);
Hbase::Hbase_scannerOpenWithStopTs_args->mk_accessors( qw( tableName startRow stopRow columns timestamp attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{startRow} = undef;
  $self->{stopRow} = undef;
  $self->{columns} = undef;
  $self->{timestamp} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{startRow}) {
      $self->{startRow} = $vals->{startRow};
    }
    if (defined $vals->{stopRow}) {
      $self->{stopRow} = $vals->{stopRow};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerOpenWithStopTs_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{startRow});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{stopRow});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size486 = 0;
          $self->{columns} = [];
          my $_etype489 = 0;
          $xfer += $input->readListBegin(\$_etype489, \$_size486);
          for (my $_i490 = 0; $_i490 < $_size486; ++$_i490)
          {
            my $elem491 = undef;
            $xfer += $input->readString(\$elem491);
            push(@{$self->{columns}},$elem491);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == Thrift::TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size492 = 0;
          $self->{attributes} = {};
          my $_ktype493 = 0;
          my $_vtype494 = 0;
          $xfer += $input->readMapBegin(\$_ktype493, \$_vtype494, \$_size492);
          for (my $_i496 = 0; $_i496 < $_size492; ++$_i496)
          {
            my $key497 = '';
            my $val498 = '';
            $xfer += $input->readString(\$key497);
            $xfer += $input->readString(\$val498);
            $self->{attributes}->{$key497} = $val498;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerOpenWithStopTs_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{startRow}) {
    $xfer += $output->writeFieldBegin('startRow', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{startRow});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{stopRow}) {
    $xfer += $output->writeFieldBegin('stopRow', Thrift::TType::STRING, 3);
    $xfer += $output->writeString($self->{stopRow});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', Thrift::TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRING, scalar(@{$self->{columns}}));
      {
        foreach my $iter499 (@{$self->{columns}}) 
        {
          $xfer += $output->writeString($iter499);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', Thrift::TType::I64, 5);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 6);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter500,$viter501) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter500);
          $xfer += $output->writeString($viter501);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerOpenWithStopTs_result;
use base qw(Class::Accessor);
Hbase::Hbase_scannerOpenWithStopTs_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerOpenWithStopTs_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerOpenWithStopTs_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerGet_args;
use base qw(Class::Accessor);
Hbase::Hbase_scannerGet_args->mk_accessors( qw( id ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{id} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerGet_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{id});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerGet_args');
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', Thrift::TType::I32, 1);
    $xfer += $output->writeI32($self->{id});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerGet_result;
use base qw(Class::Accessor);
Hbase::Hbase_scannerGet_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  $self->{ia} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
    if (defined $vals->{ia}) {
      $self->{ia} = $vals->{ia};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerGet_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size502 = 0;
          $self->{success} = [];
          my $_etype505 = 0;
          $xfer += $input->readListBegin(\$_etype505, \$_size502);
          for (my $_i506 = 0; $_i506 < $_size502; ++$_i506)
          {
            my $elem507 = undef;
            $elem507 = Hbase::TRowResult->new();
            $xfer += $elem507->read($input);
            push(@{$self->{success}},$elem507);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ia} = Hbase::IllegalArgument->new();
        $xfer += $self->{ia}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerGet_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter508 (@{$self->{success}}) 
        {
          $xfer += ${iter508}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ia}) {
    $xfer += $output->writeFieldBegin('ia', Thrift::TType::STRUCT, 2);
    $xfer += $self->{ia}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerGetList_args;
use base qw(Class::Accessor);
Hbase::Hbase_scannerGetList_args->mk_accessors( qw( id nbRows ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{id} = undef;
  $self->{nbRows} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{nbRows}) {
      $self->{nbRows} = $vals->{nbRows};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerGetList_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{id});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{nbRows});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerGetList_args');
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', Thrift::TType::I32, 1);
    $xfer += $output->writeI32($self->{id});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{nbRows}) {
    $xfer += $output->writeFieldBegin('nbRows', Thrift::TType::I32, 2);
    $xfer += $output->writeI32($self->{nbRows});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerGetList_result;
use base qw(Class::Accessor);
Hbase::Hbase_scannerGetList_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  $self->{ia} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
    if (defined $vals->{ia}) {
      $self->{ia} = $vals->{ia};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerGetList_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size509 = 0;
          $self->{success} = [];
          my $_etype512 = 0;
          $xfer += $input->readListBegin(\$_etype512, \$_size509);
          for (my $_i513 = 0; $_i513 < $_size509; ++$_i513)
          {
            my $elem514 = undef;
            $elem514 = Hbase::TRowResult->new();
            $xfer += $elem514->read($input);
            push(@{$self->{success}},$elem514);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ia} = Hbase::IllegalArgument->new();
        $xfer += $self->{ia}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerGetList_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter515 (@{$self->{success}}) 
        {
          $xfer += ${iter515}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ia}) {
    $xfer += $output->writeFieldBegin('ia', Thrift::TType::STRUCT, 2);
    $xfer += $self->{ia}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerClose_args;
use base qw(Class::Accessor);
Hbase::Hbase_scannerClose_args->mk_accessors( qw( id ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{id} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerClose_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::I32) {
        $xfer += $input->readI32(\$self->{id});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerClose_args');
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', Thrift::TType::I32, 1);
    $xfer += $output->writeI32($self->{id});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerClose_result;
use base qw(Class::Accessor);
Hbase::Hbase_scannerClose_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  $self->{ia} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
    if (defined $vals->{ia}) {
      $self->{ia} = $vals->{ia};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerClose_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ia} = Hbase::IllegalArgument->new();
        $xfer += $self->{ia}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerClose_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ia}) {
    $xfer += $output->writeFieldBegin('ia', Thrift::TType::STRUCT, 2);
    $xfer += $self->{ia}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRegionInfo_args;
use base qw(Class::Accessor);
Hbase::Hbase_getRegionInfo_args->mk_accessors( qw( row ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{row} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRegionInfo_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRegionInfo_args');
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRegionInfo_result;
use base qw(Class::Accessor);
Hbase::Hbase_getRegionInfo_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRegionInfo_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{success} = Hbase::TRegionInfo->new();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRegionInfo_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_append_args;
use base qw(Class::Accessor);
Hbase::Hbase_append_args->mk_accessors( qw( append ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{append} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{append}) {
      $self->{append} = $vals->{append};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_append_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{append} = Hbase::TAppend->new();
        $xfer += $self->{append}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_append_args');
  if (defined $self->{append}) {
    $xfer += $output->writeFieldBegin('append', Thrift::TType::STRUCT, 1);
    $xfer += $self->{append}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_append_result;
use base qw(Class::Accessor);
Hbase::Hbase_append_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_append_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::LIST) {
        {
          my $_size516 = 0;
          $self->{success} = [];
          my $_etype519 = 0;
          $xfer += $input->readListBegin(\$_etype519, \$_size516);
          for (my $_i520 = 0; $_i520 < $_size516; ++$_i520)
          {
            my $elem521 = undef;
            $elem521 = Hbase::TCell->new();
            $xfer += $elem521->read($input);
            push(@{$self->{success}},$elem521);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_append_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(Thrift::TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter522 (@{$self->{success}}) 
        {
          $xfer += ${iter522}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_checkAndPut_args;
use base qw(Class::Accessor);
Hbase::Hbase_checkAndPut_args->mk_accessors( qw( tableName row column value mput attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{column} = undef;
  $self->{value} = undef;
  $self->{mput} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{mput}) {
      $self->{mput} = $vals->{mput};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_checkAndPut_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == Thrift::TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{mput} = Hbase::Mutation->new();
        $xfer += $self->{mput}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == Thrift::TType::MAP) {
        {
          my $_size523 = 0;
          $self->{attributes} = {};
          my $_ktype524 = 0;
          my $_vtype525 = 0;
          $xfer += $input->readMapBegin(\$_ktype524, \$_vtype525, \$_size523);
          for (my $_i527 = 0; $_i527 < $_size523; ++$_i527)
          {
            my $key528 = '';
            my $val529 = '';
            $xfer += $input->readString(\$key528);
            $xfer += $input->readString(\$val529);
            $self->{attributes}->{$key528} = $val529;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_checkAndPut_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', Thrift::TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', Thrift::TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', Thrift::TType::STRING, 3);
    $xfer += $output->writeString($self->{column});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', Thrift::TType::STRING, 5);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mput}) {
    $xfer += $output->writeFieldBegin('mput', Thrift::TType::STRUCT, 6);
    $xfer += $self->{mput}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', Thrift::TType::MAP, 7);
    {
      $xfer += $output->writeMapBegin(Thrift::TType::STRING, Thrift::TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter530,$viter531) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter530);
          $xfer += $output->writeString($viter531);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_checkAndPut_result;
use base qw(Class::Accessor);
Hbase::Hbase_checkAndPut_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  $self->{ia} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
    if (defined $vals->{ia}) {
      $self->{ia} = $vals->{ia};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_checkAndPut_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1)
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == Thrift::TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == Thrift::TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{io} = Hbase::IOError->new();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == Thrift::TType::STRUCT) {
        $self->{ia} = Hbase::IllegalArgument->new();
        $xfer += $self->{ia}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_checkAndPut_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', Thrift::TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', Thrift::TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ia}) {
    $xfer += $output->writeFieldBegin('ia', Thrift::TType::STRUCT, 2);
    $xfer += $self->{ia}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::HbaseIf;

use strict;


sub enableTable{
  my $self = shift;
  my $tableName = shift;

  die 'implement interface';
}

sub disableTable{
  my $self = shift;
  my $tableName = shift;

  die 'implement interface';
}

sub isTableEnabled{
  my $self = shift;
  my $tableName = shift;

  die 'implement interface';
}

sub compact{
  my $self = shift;
  my $tableNameOrRegionName = shift;

  die 'implement interface';
}

sub majorCompact{
  my $self = shift;
  my $tableNameOrRegionName = shift;

  die 'implement interface';
}

sub getTableNames{
  my $self = shift;

  die 'implement interface';
}

sub getColumnDescriptors{
  my $self = shift;
  my $tableName = shift;

  die 'implement interface';
}

sub getTableRegions{
  my $self = shift;
  my $tableName = shift;

  die 'implement interface';
}

sub createTable{
  my $self = shift;
  my $tableName = shift;
  my $columnFamilies = shift;

  die 'implement interface';
}

sub deleteTable{
  my $self = shift;
  my $tableName = shift;

  die 'implement interface';
}

sub get{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub getVer{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $numVersions = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub getVerTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $timestamp = shift;
  my $numVersions = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub getRow{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub getRowWithColumns{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $columns = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub getRowTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $timestamp = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub getRowWithColumnsTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $columns = shift;
  my $timestamp = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub getRows{
  my $self = shift;
  my $tableName = shift;
  my $rows = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub getRowsWithColumns{
  my $self = shift;
  my $tableName = shift;
  my $rows = shift;
  my $columns = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub getRowsTs{
  my $self = shift;
  my $tableName = shift;
  my $rows = shift;
  my $timestamp = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub getRowsWithColumnsTs{
  my $self = shift;
  my $tableName = shift;
  my $rows = shift;
  my $columns = shift;
  my $timestamp = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub mutateRow{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $mutations = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub mutateRowTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $mutations = shift;
  my $timestamp = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub mutateRows{
  my $self = shift;
  my $tableName = shift;
  my $rowBatches = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub mutateRowsTs{
  my $self = shift;
  my $tableName = shift;
  my $rowBatches = shift;
  my $timestamp = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub atomicIncrement{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $value = shift;

  die 'implement interface';
}

sub deleteAll{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub deleteAllTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $timestamp = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub deleteAllRow{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub increment{
  my $self = shift;
  my $increment = shift;

  die 'implement interface';
}

sub incrementRows{
  my $self = shift;
  my $increments = shift;

  die 'implement interface';
}

sub deleteAllRowTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $timestamp = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub scannerOpenWithScan{
  my $self = shift;
  my $tableName = shift;
  my $scan = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub scannerOpen{
  my $self = shift;
  my $tableName = shift;
  my $startRow = shift;
  my $columns = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub scannerOpenWithStop{
  my $self = shift;
  my $tableName = shift;
  my $startRow = shift;
  my $stopRow = shift;
  my $columns = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub scannerOpenWithPrefix{
  my $self = shift;
  my $tableName = shift;
  my $startAndPrefix = shift;
  my $columns = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub scannerOpenTs{
  my $self = shift;
  my $tableName = shift;
  my $startRow = shift;
  my $columns = shift;
  my $timestamp = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub scannerOpenWithStopTs{
  my $self = shift;
  my $tableName = shift;
  my $startRow = shift;
  my $stopRow = shift;
  my $columns = shift;
  my $timestamp = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub scannerGet{
  my $self = shift;
  my $id = shift;

  die 'implement interface';
}

sub scannerGetList{
  my $self = shift;
  my $id = shift;
  my $nbRows = shift;

  die 'implement interface';
}

sub scannerClose{
  my $self = shift;
  my $id = shift;

  die 'implement interface';
}

sub getRegionInfo{
  my $self = shift;
  my $row = shift;

  die 'implement interface';
}

sub append{
  my $self = shift;
  my $append = shift;

  die 'implement interface';
}

sub checkAndPut{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $value = shift;
  my $mput = shift;
  my $attributes = shift;

  die 'implement interface';
}

package Hbase::HbaseRest;

use strict;


sub new {
  my ($classname, $impl) = @_;
  my $self     ={ impl => $impl };

  return bless($self,$classname);
}

sub enableTable{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  return $self->{impl}->enableTable($tableName);
}

sub disableTable{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  return $self->{impl}->disableTable($tableName);
}

sub isTableEnabled{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  return $self->{impl}->isTableEnabled($tableName);
}

sub compact{
  my ($self, $request) = @_;

  my $tableNameOrRegionName = ($request->{'tableNameOrRegionName'}) ? $request->{'tableNameOrRegionName'} : undef;
  return $self->{impl}->compact($tableNameOrRegionName);
}

sub majorCompact{
  my ($self, $request) = @_;

  my $tableNameOrRegionName = ($request->{'tableNameOrRegionName'}) ? $request->{'tableNameOrRegionName'} : undef;
  return $self->{impl}->majorCompact($tableNameOrRegionName);
}

sub getTableNames{
  my ($self, $request) = @_;

  return $self->{impl}->getTableNames();
}

sub getColumnDescriptors{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  return $self->{impl}->getColumnDescriptors($tableName);
}

sub getTableRegions{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  return $self->{impl}->getTableRegions($tableName);
}

sub createTable{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $columnFamilies = ($request->{'columnFamilies'}) ? $request->{'columnFamilies'} : undef;
  return $self->{impl}->createTable($tableName, $columnFamilies);
}

sub deleteTable{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  return $self->{impl}->deleteTable($tableName);
}

sub get{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $column = ($request->{'column'}) ? $request->{'column'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->get($tableName, $row, $column, $attributes);
}

sub getVer{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $column = ($request->{'column'}) ? $request->{'column'} : undef;
  my $numVersions = ($request->{'numVersions'}) ? $request->{'numVersions'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->getVer($tableName, $row, $column, $numVersions, $attributes);
}

sub getVerTs{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $column = ($request->{'column'}) ? $request->{'column'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $numVersions = ($request->{'numVersions'}) ? $request->{'numVersions'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->getVerTs($tableName, $row, $column, $timestamp, $numVersions, $attributes);
}

sub getRow{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->getRow($tableName, $row, $attributes);
}

sub getRowWithColumns{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $columns = ($request->{'columns'}) ? $request->{'columns'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->getRowWithColumns($tableName, $row, $columns, $attributes);
}

sub getRowTs{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->getRowTs($tableName, $row, $timestamp, $attributes);
}

sub getRowWithColumnsTs{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $columns = ($request->{'columns'}) ? $request->{'columns'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->getRowWithColumnsTs($tableName, $row, $columns, $timestamp, $attributes);
}

sub getRows{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $rows = ($request->{'rows'}) ? $request->{'rows'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->getRows($tableName, $rows, $attributes);
}

sub getRowsWithColumns{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $rows = ($request->{'rows'}) ? $request->{'rows'} : undef;
  my $columns = ($request->{'columns'}) ? $request->{'columns'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->getRowsWithColumns($tableName, $rows, $columns, $attributes);
}

sub getRowsTs{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $rows = ($request->{'rows'}) ? $request->{'rows'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->getRowsTs($tableName, $rows, $timestamp, $attributes);
}

sub getRowsWithColumnsTs{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $rows = ($request->{'rows'}) ? $request->{'rows'} : undef;
  my $columns = ($request->{'columns'}) ? $request->{'columns'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->getRowsWithColumnsTs($tableName, $rows, $columns, $timestamp, $attributes);
}

sub mutateRow{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $mutations = ($request->{'mutations'}) ? $request->{'mutations'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->mutateRow($tableName, $row, $mutations, $attributes);
}

sub mutateRowTs{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $mutations = ($request->{'mutations'}) ? $request->{'mutations'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->mutateRowTs($tableName, $row, $mutations, $timestamp, $attributes);
}

sub mutateRows{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $rowBatches = ($request->{'rowBatches'}) ? $request->{'rowBatches'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->mutateRows($tableName, $rowBatches, $attributes);
}

sub mutateRowsTs{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $rowBatches = ($request->{'rowBatches'}) ? $request->{'rowBatches'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->mutateRowsTs($tableName, $rowBatches, $timestamp, $attributes);
}

sub atomicIncrement{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $column = ($request->{'column'}) ? $request->{'column'} : undef;
  my $value = ($request->{'value'}) ? $request->{'value'} : undef;
  return $self->{impl}->atomicIncrement($tableName, $row, $column, $value);
}

sub deleteAll{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $column = ($request->{'column'}) ? $request->{'column'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->deleteAll($tableName, $row, $column, $attributes);
}

sub deleteAllTs{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $column = ($request->{'column'}) ? $request->{'column'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->deleteAllTs($tableName, $row, $column, $timestamp, $attributes);
}

sub deleteAllRow{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->deleteAllRow($tableName, $row, $attributes);
}

sub increment{
  my ($self, $request) = @_;

  my $increment = ($request->{'increment'}) ? $request->{'increment'} : undef;
  return $self->{impl}->increment($increment);
}

sub incrementRows{
  my ($self, $request) = @_;

  my $increments = ($request->{'increments'}) ? $request->{'increments'} : undef;
  return $self->{impl}->incrementRows($increments);
}

sub deleteAllRowTs{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->deleteAllRowTs($tableName, $row, $timestamp, $attributes);
}

sub scannerOpenWithScan{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $scan = ($request->{'scan'}) ? $request->{'scan'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->scannerOpenWithScan($tableName, $scan, $attributes);
}

sub scannerOpen{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $startRow = ($request->{'startRow'}) ? $request->{'startRow'} : undef;
  my $columns = ($request->{'columns'}) ? $request->{'columns'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->scannerOpen($tableName, $startRow, $columns, $attributes);
}

sub scannerOpenWithStop{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $startRow = ($request->{'startRow'}) ? $request->{'startRow'} : undef;
  my $stopRow = ($request->{'stopRow'}) ? $request->{'stopRow'} : undef;
  my $columns = ($request->{'columns'}) ? $request->{'columns'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->scannerOpenWithStop($tableName, $startRow, $stopRow, $columns, $attributes);
}

sub scannerOpenWithPrefix{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $startAndPrefix = ($request->{'startAndPrefix'}) ? $request->{'startAndPrefix'} : undef;
  my $columns = ($request->{'columns'}) ? $request->{'columns'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->scannerOpenWithPrefix($tableName, $startAndPrefix, $columns, $attributes);
}

sub scannerOpenTs{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $startRow = ($request->{'startRow'}) ? $request->{'startRow'} : undef;
  my $columns = ($request->{'columns'}) ? $request->{'columns'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->scannerOpenTs($tableName, $startRow, $columns, $timestamp, $attributes);
}

sub scannerOpenWithStopTs{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $startRow = ($request->{'startRow'}) ? $request->{'startRow'} : undef;
  my $stopRow = ($request->{'stopRow'}) ? $request->{'stopRow'} : undef;
  my $columns = ($request->{'columns'}) ? $request->{'columns'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->scannerOpenWithStopTs($tableName, $startRow, $stopRow, $columns, $timestamp, $attributes);
}

sub scannerGet{
  my ($self, $request) = @_;

  my $id = ($request->{'id'}) ? $request->{'id'} : undef;
  return $self->{impl}->scannerGet($id);
}

sub scannerGetList{
  my ($self, $request) = @_;

  my $id = ($request->{'id'}) ? $request->{'id'} : undef;
  my $nbRows = ($request->{'nbRows'}) ? $request->{'nbRows'} : undef;
  return $self->{impl}->scannerGetList($id, $nbRows);
}

sub scannerClose{
  my ($self, $request) = @_;

  my $id = ($request->{'id'}) ? $request->{'id'} : undef;
  return $self->{impl}->scannerClose($id);
}

sub getRegionInfo{
  my ($self, $request) = @_;

  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  return $self->{impl}->getRegionInfo($row);
}

sub append{
  my ($self, $request) = @_;

  my $append = ($request->{'append'}) ? $request->{'append'} : undef;
  return $self->{impl}->append($append);
}

sub checkAndPut{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $column = ($request->{'column'}) ? $request->{'column'} : undef;
  my $value = ($request->{'value'}) ? $request->{'value'} : undef;
  my $mput = ($request->{'mput'}) ? $request->{'mput'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->checkAndPut($tableName, $row, $column, $value, $mput, $attributes);
}

package Hbase::HbaseClient;


use base qw(Hbase::HbaseIf);
sub new {
  my ($classname, $input, $output) = @_;
  my $self      = {};
  $self->{input}  = $input;
  $self->{output} = defined $output ? $output : $input;
  $self->{seqid}  = 0;
  return bless($self,$classname);
}

sub enableTable{
  my $self = shift;
  my $tableName = shift;

    $self->send_enableTable($tableName);
  $self->recv_enableTable();
}

sub send_enableTable{
  my $self = shift;
  my $tableName = shift;

  $self->{output}->writeMessageBegin('enableTable', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_enableTable_args->new();
  $args->{tableName} = $tableName;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_enableTable{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_enableTable_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  return;
}
sub disableTable{
  my $self = shift;
  my $tableName = shift;

    $self->send_disableTable($tableName);
  $self->recv_disableTable();
}

sub send_disableTable{
  my $self = shift;
  my $tableName = shift;

  $self->{output}->writeMessageBegin('disableTable', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_disableTable_args->new();
  $args->{tableName} = $tableName;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_disableTable{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_disableTable_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  return;
}
sub isTableEnabled{
  my $self = shift;
  my $tableName = shift;

    $self->send_isTableEnabled($tableName);
  return $self->recv_isTableEnabled();
}

sub send_isTableEnabled{
  my $self = shift;
  my $tableName = shift;

  $self->{output}->writeMessageBegin('isTableEnabled', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_isTableEnabled_args->new();
  $args->{tableName} = $tableName;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_isTableEnabled{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_isTableEnabled_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "isTableEnabled failed: unknown result";
}
sub compact{
  my $self = shift;
  my $tableNameOrRegionName = shift;

    $self->send_compact($tableNameOrRegionName);
  $self->recv_compact();
}

sub send_compact{
  my $self = shift;
  my $tableNameOrRegionName = shift;

  $self->{output}->writeMessageBegin('compact', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_compact_args->new();
  $args->{tableNameOrRegionName} = $tableNameOrRegionName;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_compact{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_compact_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  return;
}
sub majorCompact{
  my $self = shift;
  my $tableNameOrRegionName = shift;

    $self->send_majorCompact($tableNameOrRegionName);
  $self->recv_majorCompact();
}

sub send_majorCompact{
  my $self = shift;
  my $tableNameOrRegionName = shift;

  $self->{output}->writeMessageBegin('majorCompact', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_majorCompact_args->new();
  $args->{tableNameOrRegionName} = $tableNameOrRegionName;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_majorCompact{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_majorCompact_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  return;
}
sub getTableNames{
  my $self = shift;

    $self->send_getTableNames();
  return $self->recv_getTableNames();
}

sub send_getTableNames{
  my $self = shift;

  $self->{output}->writeMessageBegin('getTableNames', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_getTableNames_args->new();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getTableNames{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_getTableNames_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getTableNames failed: unknown result";
}
sub getColumnDescriptors{
  my $self = shift;
  my $tableName = shift;

    $self->send_getColumnDescriptors($tableName);
  return $self->recv_getColumnDescriptors();
}

sub send_getColumnDescriptors{
  my $self = shift;
  my $tableName = shift;

  $self->{output}->writeMessageBegin('getColumnDescriptors', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_getColumnDescriptors_args->new();
  $args->{tableName} = $tableName;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getColumnDescriptors{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_getColumnDescriptors_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getColumnDescriptors failed: unknown result";
}
sub getTableRegions{
  my $self = shift;
  my $tableName = shift;

    $self->send_getTableRegions($tableName);
  return $self->recv_getTableRegions();
}

sub send_getTableRegions{
  my $self = shift;
  my $tableName = shift;

  $self->{output}->writeMessageBegin('getTableRegions', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_getTableRegions_args->new();
  $args->{tableName} = $tableName;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getTableRegions{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_getTableRegions_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getTableRegions failed: unknown result";
}
sub createTable{
  my $self = shift;
  my $tableName = shift;
  my $columnFamilies = shift;

    $self->send_createTable($tableName, $columnFamilies);
  $self->recv_createTable();
}

sub send_createTable{
  my $self = shift;
  my $tableName = shift;
  my $columnFamilies = shift;

  $self->{output}->writeMessageBegin('createTable', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_createTable_args->new();
  $args->{tableName} = $tableName;
  $args->{columnFamilies} = $columnFamilies;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_createTable{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_createTable_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  if (defined $result->{ia}) {
    die $result->{ia};
  }
  if (defined $result->{exist}) {
    die $result->{exist};
  }
  return;
}
sub deleteTable{
  my $self = shift;
  my $tableName = shift;

    $self->send_deleteTable($tableName);
  $self->recv_deleteTable();
}

sub send_deleteTable{
  my $self = shift;
  my $tableName = shift;

  $self->{output}->writeMessageBegin('deleteTable', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_deleteTable_args->new();
  $args->{tableName} = $tableName;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_deleteTable{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_deleteTable_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  return;
}
sub get{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $attributes = shift;

    $self->send_get($tableName, $row, $column, $attributes);
  return $self->recv_get();
}

sub send_get{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('get', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_get_args->new();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{column} = $column;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_get_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "get failed: unknown result";
}
sub getVer{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $numVersions = shift;
  my $attributes = shift;

    $self->send_getVer($tableName, $row, $column, $numVersions, $attributes);
  return $self->recv_getVer();
}

sub send_getVer{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $numVersions = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('getVer', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_getVer_args->new();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{column} = $column;
  $args->{numVersions} = $numVersions;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getVer{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_getVer_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getVer failed: unknown result";
}
sub getVerTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $timestamp = shift;
  my $numVersions = shift;
  my $attributes = shift;

    $self->send_getVerTs($tableName, $row, $column, $timestamp, $numVersions, $attributes);
  return $self->recv_getVerTs();
}

sub send_getVerTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $timestamp = shift;
  my $numVersions = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('getVerTs', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_getVerTs_args->new();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{column} = $column;
  $args->{timestamp} = $timestamp;
  $args->{numVersions} = $numVersions;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getVerTs{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_getVerTs_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getVerTs failed: unknown result";
}
sub getRow{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $attributes = shift;

    $self->send_getRow($tableName, $row, $attributes);
  return $self->recv_getRow();
}

sub send_getRow{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('getRow', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_getRow_args->new();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getRow{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_getRow_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getRow failed: unknown result";
}
sub getRowWithColumns{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $columns = shift;
  my $attributes = shift;

    $self->send_getRowWithColumns($tableName, $row, $columns, $attributes);
  return $self->recv_getRowWithColumns();
}

sub send_getRowWithColumns{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $columns = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('getRowWithColumns', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_getRowWithColumns_args->new();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{columns} = $columns;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getRowWithColumns{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_getRowWithColumns_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getRowWithColumns failed: unknown result";
}
sub getRowTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $timestamp = shift;
  my $attributes = shift;

    $self->send_getRowTs($tableName, $row, $timestamp, $attributes);
  return $self->recv_getRowTs();
}

sub send_getRowTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $timestamp = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('getRowTs', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_getRowTs_args->new();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{timestamp} = $timestamp;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getRowTs{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_getRowTs_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getRowTs failed: unknown result";
}
sub getRowWithColumnsTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $columns = shift;
  my $timestamp = shift;
  my $attributes = shift;

    $self->send_getRowWithColumnsTs($tableName, $row, $columns, $timestamp, $attributes);
  return $self->recv_getRowWithColumnsTs();
}

sub send_getRowWithColumnsTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $columns = shift;
  my $timestamp = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('getRowWithColumnsTs', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_getRowWithColumnsTs_args->new();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{columns} = $columns;
  $args->{timestamp} = $timestamp;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getRowWithColumnsTs{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_getRowWithColumnsTs_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getRowWithColumnsTs failed: unknown result";
}
sub getRows{
  my $self = shift;
  my $tableName = shift;
  my $rows = shift;
  my $attributes = shift;

    $self->send_getRows($tableName, $rows, $attributes);
  return $self->recv_getRows();
}

sub send_getRows{
  my $self = shift;
  my $tableName = shift;
  my $rows = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('getRows', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_getRows_args->new();
  $args->{tableName} = $tableName;
  $args->{rows} = $rows;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getRows{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_getRows_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getRows failed: unknown result";
}
sub getRowsWithColumns{
  my $self = shift;
  my $tableName = shift;
  my $rows = shift;
  my $columns = shift;
  my $attributes = shift;

    $self->send_getRowsWithColumns($tableName, $rows, $columns, $attributes);
  return $self->recv_getRowsWithColumns();
}

sub send_getRowsWithColumns{
  my $self = shift;
  my $tableName = shift;
  my $rows = shift;
  my $columns = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('getRowsWithColumns', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_getRowsWithColumns_args->new();
  $args->{tableName} = $tableName;
  $args->{rows} = $rows;
  $args->{columns} = $columns;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getRowsWithColumns{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_getRowsWithColumns_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getRowsWithColumns failed: unknown result";
}
sub getRowsTs{
  my $self = shift;
  my $tableName = shift;
  my $rows = shift;
  my $timestamp = shift;
  my $attributes = shift;

    $self->send_getRowsTs($tableName, $rows, $timestamp, $attributes);
  return $self->recv_getRowsTs();
}

sub send_getRowsTs{
  my $self = shift;
  my $tableName = shift;
  my $rows = shift;
  my $timestamp = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('getRowsTs', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_getRowsTs_args->new();
  $args->{tableName} = $tableName;
  $args->{rows} = $rows;
  $args->{timestamp} = $timestamp;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getRowsTs{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_getRowsTs_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getRowsTs failed: unknown result";
}
sub getRowsWithColumnsTs{
  my $self = shift;
  my $tableName = shift;
  my $rows = shift;
  my $columns = shift;
  my $timestamp = shift;
  my $attributes = shift;

    $self->send_getRowsWithColumnsTs($tableName, $rows, $columns, $timestamp, $attributes);
  return $self->recv_getRowsWithColumnsTs();
}

sub send_getRowsWithColumnsTs{
  my $self = shift;
  my $tableName = shift;
  my $rows = shift;
  my $columns = shift;
  my $timestamp = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('getRowsWithColumnsTs', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_getRowsWithColumnsTs_args->new();
  $args->{tableName} = $tableName;
  $args->{rows} = $rows;
  $args->{columns} = $columns;
  $args->{timestamp} = $timestamp;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getRowsWithColumnsTs{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_getRowsWithColumnsTs_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getRowsWithColumnsTs failed: unknown result";
}
sub mutateRow{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $mutations = shift;
  my $attributes = shift;

    $self->send_mutateRow($tableName, $row, $mutations, $attributes);
  $self->recv_mutateRow();
}

sub send_mutateRow{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $mutations = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('mutateRow', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_mutateRow_args->new();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{mutations} = $mutations;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutateRow{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_mutateRow_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  if (defined $result->{ia}) {
    die $result->{ia};
  }
  return;
}
sub mutateRowTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $mutations = shift;
  my $timestamp = shift;
  my $attributes = shift;

    $self->send_mutateRowTs($tableName, $row, $mutations, $timestamp, $attributes);
  $self->recv_mutateRowTs();
}

sub send_mutateRowTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $mutations = shift;
  my $timestamp = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('mutateRowTs', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_mutateRowTs_args->new();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{mutations} = $mutations;
  $args->{timestamp} = $timestamp;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutateRowTs{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_mutateRowTs_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  if (defined $result->{ia}) {
    die $result->{ia};
  }
  return;
}
sub mutateRows{
  my $self = shift;
  my $tableName = shift;
  my $rowBatches = shift;
  my $attributes = shift;

    $self->send_mutateRows($tableName, $rowBatches, $attributes);
  $self->recv_mutateRows();
}

sub send_mutateRows{
  my $self = shift;
  my $tableName = shift;
  my $rowBatches = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('mutateRows', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_mutateRows_args->new();
  $args->{tableName} = $tableName;
  $args->{rowBatches} = $rowBatches;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutateRows{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_mutateRows_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  if (defined $result->{ia}) {
    die $result->{ia};
  }
  return;
}
sub mutateRowsTs{
  my $self = shift;
  my $tableName = shift;
  my $rowBatches = shift;
  my $timestamp = shift;
  my $attributes = shift;

    $self->send_mutateRowsTs($tableName, $rowBatches, $timestamp, $attributes);
  $self->recv_mutateRowsTs();
}

sub send_mutateRowsTs{
  my $self = shift;
  my $tableName = shift;
  my $rowBatches = shift;
  my $timestamp = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('mutateRowsTs', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_mutateRowsTs_args->new();
  $args->{tableName} = $tableName;
  $args->{rowBatches} = $rowBatches;
  $args->{timestamp} = $timestamp;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutateRowsTs{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_mutateRowsTs_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  if (defined $result->{ia}) {
    die $result->{ia};
  }
  return;
}
sub atomicIncrement{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $value = shift;

    $self->send_atomicIncrement($tableName, $row, $column, $value);
  return $self->recv_atomicIncrement();
}

sub send_atomicIncrement{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $value = shift;

  $self->{output}->writeMessageBegin('atomicIncrement', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_atomicIncrement_args->new();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{column} = $column;
  $args->{value} = $value;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_atomicIncrement{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_atomicIncrement_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  if (defined $result->{ia}) {
    die $result->{ia};
  }
  die "atomicIncrement failed: unknown result";
}
sub deleteAll{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $attributes = shift;

    $self->send_deleteAll($tableName, $row, $column, $attributes);
  $self->recv_deleteAll();
}

sub send_deleteAll{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('deleteAll', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_deleteAll_args->new();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{column} = $column;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_deleteAll{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_deleteAll_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  return;
}
sub deleteAllTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $timestamp = shift;
  my $attributes = shift;

    $self->send_deleteAllTs($tableName, $row, $column, $timestamp, $attributes);
  $self->recv_deleteAllTs();
}

sub send_deleteAllTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $timestamp = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('deleteAllTs', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_deleteAllTs_args->new();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{column} = $column;
  $args->{timestamp} = $timestamp;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_deleteAllTs{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_deleteAllTs_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  return;
}
sub deleteAllRow{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $attributes = shift;

    $self->send_deleteAllRow($tableName, $row, $attributes);
  $self->recv_deleteAllRow();
}

sub send_deleteAllRow{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('deleteAllRow', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_deleteAllRow_args->new();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_deleteAllRow{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_deleteAllRow_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  return;
}
sub increment{
  my $self = shift;
  my $increment = shift;

    $self->send_increment($increment);
  $self->recv_increment();
}

sub send_increment{
  my $self = shift;
  my $increment = shift;

  $self->{output}->writeMessageBegin('increment', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_increment_args->new();
  $args->{increment} = $increment;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_increment{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_increment_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  return;
}
sub incrementRows{
  my $self = shift;
  my $increments = shift;

    $self->send_incrementRows($increments);
  $self->recv_incrementRows();
}

sub send_incrementRows{
  my $self = shift;
  my $increments = shift;

  $self->{output}->writeMessageBegin('incrementRows', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_incrementRows_args->new();
  $args->{increments} = $increments;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_incrementRows{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_incrementRows_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  return;
}
sub deleteAllRowTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $timestamp = shift;
  my $attributes = shift;

    $self->send_deleteAllRowTs($tableName, $row, $timestamp, $attributes);
  $self->recv_deleteAllRowTs();
}

sub send_deleteAllRowTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $timestamp = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('deleteAllRowTs', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_deleteAllRowTs_args->new();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{timestamp} = $timestamp;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_deleteAllRowTs{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_deleteAllRowTs_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  return;
}
sub scannerOpenWithScan{
  my $self = shift;
  my $tableName = shift;
  my $scan = shift;
  my $attributes = shift;

    $self->send_scannerOpenWithScan($tableName, $scan, $attributes);
  return $self->recv_scannerOpenWithScan();
}

sub send_scannerOpenWithScan{
  my $self = shift;
  my $tableName = shift;
  my $scan = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('scannerOpenWithScan', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_scannerOpenWithScan_args->new();
  $args->{tableName} = $tableName;
  $args->{scan} = $scan;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scannerOpenWithScan{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_scannerOpenWithScan_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "scannerOpenWithScan failed: unknown result";
}
sub scannerOpen{
  my $self = shift;
  my $tableName = shift;
  my $startRow = shift;
  my $columns = shift;
  my $attributes = shift;

    $self->send_scannerOpen($tableName, $startRow, $columns, $attributes);
  return $self->recv_scannerOpen();
}

sub send_scannerOpen{
  my $self = shift;
  my $tableName = shift;
  my $startRow = shift;
  my $columns = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('scannerOpen', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_scannerOpen_args->new();
  $args->{tableName} = $tableName;
  $args->{startRow} = $startRow;
  $args->{columns} = $columns;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scannerOpen{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_scannerOpen_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "scannerOpen failed: unknown result";
}
sub scannerOpenWithStop{
  my $self = shift;
  my $tableName = shift;
  my $startRow = shift;
  my $stopRow = shift;
  my $columns = shift;
  my $attributes = shift;

    $self->send_scannerOpenWithStop($tableName, $startRow, $stopRow, $columns, $attributes);
  return $self->recv_scannerOpenWithStop();
}

sub send_scannerOpenWithStop{
  my $self = shift;
  my $tableName = shift;
  my $startRow = shift;
  my $stopRow = shift;
  my $columns = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('scannerOpenWithStop', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_scannerOpenWithStop_args->new();
  $args->{tableName} = $tableName;
  $args->{startRow} = $startRow;
  $args->{stopRow} = $stopRow;
  $args->{columns} = $columns;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scannerOpenWithStop{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_scannerOpenWithStop_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "scannerOpenWithStop failed: unknown result";
}
sub scannerOpenWithPrefix{
  my $self = shift;
  my $tableName = shift;
  my $startAndPrefix = shift;
  my $columns = shift;
  my $attributes = shift;

    $self->send_scannerOpenWithPrefix($tableName, $startAndPrefix, $columns, $attributes);
  return $self->recv_scannerOpenWithPrefix();
}

sub send_scannerOpenWithPrefix{
  my $self = shift;
  my $tableName = shift;
  my $startAndPrefix = shift;
  my $columns = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('scannerOpenWithPrefix', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_scannerOpenWithPrefix_args->new();
  $args->{tableName} = $tableName;
  $args->{startAndPrefix} = $startAndPrefix;
  $args->{columns} = $columns;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scannerOpenWithPrefix{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_scannerOpenWithPrefix_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "scannerOpenWithPrefix failed: unknown result";
}
sub scannerOpenTs{
  my $self = shift;
  my $tableName = shift;
  my $startRow = shift;
  my $columns = shift;
  my $timestamp = shift;
  my $attributes = shift;

    $self->send_scannerOpenTs($tableName, $startRow, $columns, $timestamp, $attributes);
  return $self->recv_scannerOpenTs();
}

sub send_scannerOpenTs{
  my $self = shift;
  my $tableName = shift;
  my $startRow = shift;
  my $columns = shift;
  my $timestamp = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('scannerOpenTs', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_scannerOpenTs_args->new();
  $args->{tableName} = $tableName;
  $args->{startRow} = $startRow;
  $args->{columns} = $columns;
  $args->{timestamp} = $timestamp;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scannerOpenTs{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_scannerOpenTs_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "scannerOpenTs failed: unknown result";
}
sub scannerOpenWithStopTs{
  my $self = shift;
  my $tableName = shift;
  my $startRow = shift;
  my $stopRow = shift;
  my $columns = shift;
  my $timestamp = shift;
  my $attributes = shift;

    $self->send_scannerOpenWithStopTs($tableName, $startRow, $stopRow, $columns, $timestamp, $attributes);
  return $self->recv_scannerOpenWithStopTs();
}

sub send_scannerOpenWithStopTs{
  my $self = shift;
  my $tableName = shift;
  my $startRow = shift;
  my $stopRow = shift;
  my $columns = shift;
  my $timestamp = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('scannerOpenWithStopTs', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_scannerOpenWithStopTs_args->new();
  $args->{tableName} = $tableName;
  $args->{startRow} = $startRow;
  $args->{stopRow} = $stopRow;
  $args->{columns} = $columns;
  $args->{timestamp} = $timestamp;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scannerOpenWithStopTs{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_scannerOpenWithStopTs_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "scannerOpenWithStopTs failed: unknown result";
}
sub scannerGet{
  my $self = shift;
  my $id = shift;

    $self->send_scannerGet($id);
  return $self->recv_scannerGet();
}

sub send_scannerGet{
  my $self = shift;
  my $id = shift;

  $self->{output}->writeMessageBegin('scannerGet', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_scannerGet_args->new();
  $args->{id} = $id;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scannerGet{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_scannerGet_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  if (defined $result->{ia}) {
    die $result->{ia};
  }
  die "scannerGet failed: unknown result";
}
sub scannerGetList{
  my $self = shift;
  my $id = shift;
  my $nbRows = shift;

    $self->send_scannerGetList($id, $nbRows);
  return $self->recv_scannerGetList();
}

sub send_scannerGetList{
  my $self = shift;
  my $id = shift;
  my $nbRows = shift;

  $self->{output}->writeMessageBegin('scannerGetList', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_scannerGetList_args->new();
  $args->{id} = $id;
  $args->{nbRows} = $nbRows;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scannerGetList{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_scannerGetList_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  if (defined $result->{ia}) {
    die $result->{ia};
  }
  die "scannerGetList failed: unknown result";
}
sub scannerClose{
  my $self = shift;
  my $id = shift;

    $self->send_scannerClose($id);
  $self->recv_scannerClose();
}

sub send_scannerClose{
  my $self = shift;
  my $id = shift;

  $self->{output}->writeMessageBegin('scannerClose', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_scannerClose_args->new();
  $args->{id} = $id;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scannerClose{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_scannerClose_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  if (defined $result->{ia}) {
    die $result->{ia};
  }
  return;
}
sub getRegionInfo{
  my $self = shift;
  my $row = shift;

    $self->send_getRegionInfo($row);
  return $self->recv_getRegionInfo();
}

sub send_getRegionInfo{
  my $self = shift;
  my $row = shift;

  $self->{output}->writeMessageBegin('getRegionInfo', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_getRegionInfo_args->new();
  $args->{row} = $row;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getRegionInfo{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_getRegionInfo_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getRegionInfo failed: unknown result";
}
sub append{
  my $self = shift;
  my $append = shift;

    $self->send_append($append);
  return $self->recv_append();
}

sub send_append{
  my $self = shift;
  my $append = shift;

  $self->{output}->writeMessageBegin('append', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_append_args->new();
  $args->{append} = $append;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_append{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_append_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "append failed: unknown result";
}
sub checkAndPut{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $value = shift;
  my $mput = shift;
  my $attributes = shift;

    $self->send_checkAndPut($tableName, $row, $column, $value, $mput, $attributes);
  return $self->recv_checkAndPut();
}

sub send_checkAndPut{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $value = shift;
  my $mput = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('checkAndPut', Thrift::TMessageType::CALL, $self->{seqid});
  my $args = Hbase::Hbase_checkAndPut_args->new();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{column} = $column;
  $args->{value} = $value;
  $args->{mput} = $mput;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_checkAndPut{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == Thrift::TMessageType::EXCEPTION) {
    my $x = Thrift::TApplicationException->new();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = Hbase::Hbase_checkAndPut_result->new();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  if (defined $result->{ia}) {
    die $result->{ia};
  }
  die "checkAndPut failed: unknown result";
}
package Hbase::HbaseProcessor;

use strict;


sub new {
    my ($classname, $handler) = @_;
    my $self      = {};
    $self->{handler} = $handler;
    return bless ($self, $classname);
}

sub process {
    my ($self, $input, $output) = @_;
    my $rseqid = 0;
    my $fname  = undef;
    my $mtype  = 0;

    $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
    my $methodname = 'process_'.$fname;
    if (!$self->can($methodname)) {
      $input->skip(Thrift::TType::STRUCT);
      $input->readMessageEnd();
      my $x = Thrift::TApplicationException->new('Function '.$fname.' not implemented.', Thrift::TApplicationException::UNKNOWN_METHOD);
      $output->writeMessageBegin($fname, Thrift::TMessageType::EXCEPTION, $rseqid);
      $x->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      return;
    }
    $self->$methodname($rseqid, $input, $output);
    return 1;
}

sub process_enableTable {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_enableTable_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_enableTable_result->new();
    eval {
      $self->{handler}->enableTable($args->tableName);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('enableTable', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('enableTable', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_disableTable {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_disableTable_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_disableTable_result->new();
    eval {
      $self->{handler}->disableTable($args->tableName);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('disableTable', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('disableTable', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_isTableEnabled {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_isTableEnabled_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_isTableEnabled_result->new();
    eval {
      $result->{success} = $self->{handler}->isTableEnabled($args->tableName);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('isTableEnabled', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('isTableEnabled', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_compact {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_compact_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_compact_result->new();
    eval {
      $self->{handler}->compact($args->tableNameOrRegionName);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('compact', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('compact', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_majorCompact {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_majorCompact_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_majorCompact_result->new();
    eval {
      $self->{handler}->majorCompact($args->tableNameOrRegionName);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('majorCompact', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('majorCompact', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getTableNames {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_getTableNames_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_getTableNames_result->new();
    eval {
      $result->{success} = $self->{handler}->getTableNames();
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('getTableNames', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('getTableNames', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getColumnDescriptors {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_getColumnDescriptors_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_getColumnDescriptors_result->new();
    eval {
      $result->{success} = $self->{handler}->getColumnDescriptors($args->tableName);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('getColumnDescriptors', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('getColumnDescriptors', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getTableRegions {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_getTableRegions_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_getTableRegions_result->new();
    eval {
      $result->{success} = $self->{handler}->getTableRegions($args->tableName);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('getTableRegions', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('getTableRegions', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_createTable {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_createTable_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_createTable_result->new();
    eval {
      $self->{handler}->createTable($args->tableName, $args->columnFamilies);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Hbase::IllegalArgument') ){ 
      $result->{ia} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Hbase::AlreadyExists') ){ 
      $result->{exist} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('createTable', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('createTable', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_deleteTable {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_deleteTable_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_deleteTable_result->new();
    eval {
      $self->{handler}->deleteTable($args->tableName);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('deleteTable', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('deleteTable', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_get_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_get_result->new();
    eval {
      $result->{success} = $self->{handler}->get($args->tableName, $args->row, $args->column, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('get', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('get', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getVer {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_getVer_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_getVer_result->new();
    eval {
      $result->{success} = $self->{handler}->getVer($args->tableName, $args->row, $args->column, $args->numVersions, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('getVer', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('getVer', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getVerTs {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_getVerTs_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_getVerTs_result->new();
    eval {
      $result->{success} = $self->{handler}->getVerTs($args->tableName, $args->row, $args->column, $args->timestamp, $args->numVersions, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('getVerTs', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('getVerTs', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getRow {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_getRow_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_getRow_result->new();
    eval {
      $result->{success} = $self->{handler}->getRow($args->tableName, $args->row, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('getRow', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('getRow', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getRowWithColumns {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_getRowWithColumns_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_getRowWithColumns_result->new();
    eval {
      $result->{success} = $self->{handler}->getRowWithColumns($args->tableName, $args->row, $args->columns, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('getRowWithColumns', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('getRowWithColumns', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getRowTs {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_getRowTs_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_getRowTs_result->new();
    eval {
      $result->{success} = $self->{handler}->getRowTs($args->tableName, $args->row, $args->timestamp, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('getRowTs', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('getRowTs', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getRowWithColumnsTs {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_getRowWithColumnsTs_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_getRowWithColumnsTs_result->new();
    eval {
      $result->{success} = $self->{handler}->getRowWithColumnsTs($args->tableName, $args->row, $args->columns, $args->timestamp, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('getRowWithColumnsTs', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('getRowWithColumnsTs', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getRows {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_getRows_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_getRows_result->new();
    eval {
      $result->{success} = $self->{handler}->getRows($args->tableName, $args->rows, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('getRows', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('getRows', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getRowsWithColumns {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_getRowsWithColumns_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_getRowsWithColumns_result->new();
    eval {
      $result->{success} = $self->{handler}->getRowsWithColumns($args->tableName, $args->rows, $args->columns, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('getRowsWithColumns', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('getRowsWithColumns', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getRowsTs {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_getRowsTs_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_getRowsTs_result->new();
    eval {
      $result->{success} = $self->{handler}->getRowsTs($args->tableName, $args->rows, $args->timestamp, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('getRowsTs', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('getRowsTs', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getRowsWithColumnsTs {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_getRowsWithColumnsTs_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_getRowsWithColumnsTs_result->new();
    eval {
      $result->{success} = $self->{handler}->getRowsWithColumnsTs($args->tableName, $args->rows, $args->columns, $args->timestamp, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('getRowsWithColumnsTs', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('getRowsWithColumnsTs', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutateRow {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_mutateRow_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_mutateRow_result->new();
    eval {
      $self->{handler}->mutateRow($args->tableName, $args->row, $args->mutations, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Hbase::IllegalArgument') ){ 
      $result->{ia} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('mutateRow', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('mutateRow', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutateRowTs {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_mutateRowTs_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_mutateRowTs_result->new();
    eval {
      $self->{handler}->mutateRowTs($args->tableName, $args->row, $args->mutations, $args->timestamp, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Hbase::IllegalArgument') ){ 
      $result->{ia} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('mutateRowTs', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('mutateRowTs', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutateRows {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_mutateRows_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_mutateRows_result->new();
    eval {
      $self->{handler}->mutateRows($args->tableName, $args->rowBatches, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Hbase::IllegalArgument') ){ 
      $result->{ia} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('mutateRows', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('mutateRows', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutateRowsTs {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_mutateRowsTs_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_mutateRowsTs_result->new();
    eval {
      $self->{handler}->mutateRowsTs($args->tableName, $args->rowBatches, $args->timestamp, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Hbase::IllegalArgument') ){ 
      $result->{ia} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('mutateRowsTs', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('mutateRowsTs', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_atomicIncrement {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_atomicIncrement_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_atomicIncrement_result->new();
    eval {
      $result->{success} = $self->{handler}->atomicIncrement($args->tableName, $args->row, $args->column, $args->value);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Hbase::IllegalArgument') ){ 
      $result->{ia} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('atomicIncrement', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('atomicIncrement', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_deleteAll {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_deleteAll_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_deleteAll_result->new();
    eval {
      $self->{handler}->deleteAll($args->tableName, $args->row, $args->column, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('deleteAll', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('deleteAll', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_deleteAllTs {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_deleteAllTs_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_deleteAllTs_result->new();
    eval {
      $self->{handler}->deleteAllTs($args->tableName, $args->row, $args->column, $args->timestamp, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('deleteAllTs', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('deleteAllTs', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_deleteAllRow {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_deleteAllRow_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_deleteAllRow_result->new();
    eval {
      $self->{handler}->deleteAllRow($args->tableName, $args->row, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('deleteAllRow', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('deleteAllRow', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_increment {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_increment_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_increment_result->new();
    eval {
      $self->{handler}->increment($args->increment);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('increment', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('increment', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_incrementRows {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_incrementRows_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_incrementRows_result->new();
    eval {
      $self->{handler}->incrementRows($args->increments);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('incrementRows', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('incrementRows', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_deleteAllRowTs {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_deleteAllRowTs_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_deleteAllRowTs_result->new();
    eval {
      $self->{handler}->deleteAllRowTs($args->tableName, $args->row, $args->timestamp, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('deleteAllRowTs', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('deleteAllRowTs', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scannerOpenWithScan {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_scannerOpenWithScan_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_scannerOpenWithScan_result->new();
    eval {
      $result->{success} = $self->{handler}->scannerOpenWithScan($args->tableName, $args->scan, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('scannerOpenWithScan', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('scannerOpenWithScan', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scannerOpen {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_scannerOpen_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_scannerOpen_result->new();
    eval {
      $result->{success} = $self->{handler}->scannerOpen($args->tableName, $args->startRow, $args->columns, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('scannerOpen', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('scannerOpen', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scannerOpenWithStop {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_scannerOpenWithStop_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_scannerOpenWithStop_result->new();
    eval {
      $result->{success} = $self->{handler}->scannerOpenWithStop($args->tableName, $args->startRow, $args->stopRow, $args->columns, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('scannerOpenWithStop', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('scannerOpenWithStop', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scannerOpenWithPrefix {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_scannerOpenWithPrefix_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_scannerOpenWithPrefix_result->new();
    eval {
      $result->{success} = $self->{handler}->scannerOpenWithPrefix($args->tableName, $args->startAndPrefix, $args->columns, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('scannerOpenWithPrefix', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('scannerOpenWithPrefix', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scannerOpenTs {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_scannerOpenTs_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_scannerOpenTs_result->new();
    eval {
      $result->{success} = $self->{handler}->scannerOpenTs($args->tableName, $args->startRow, $args->columns, $args->timestamp, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('scannerOpenTs', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('scannerOpenTs', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scannerOpenWithStopTs {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_scannerOpenWithStopTs_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_scannerOpenWithStopTs_result->new();
    eval {
      $result->{success} = $self->{handler}->scannerOpenWithStopTs($args->tableName, $args->startRow, $args->stopRow, $args->columns, $args->timestamp, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('scannerOpenWithStopTs', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('scannerOpenWithStopTs', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scannerGet {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_scannerGet_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_scannerGet_result->new();
    eval {
      $result->{success} = $self->{handler}->scannerGet($args->id);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Hbase::IllegalArgument') ){ 
      $result->{ia} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('scannerGet', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('scannerGet', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scannerGetList {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_scannerGetList_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_scannerGetList_result->new();
    eval {
      $result->{success} = $self->{handler}->scannerGetList($args->id, $args->nbRows);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Hbase::IllegalArgument') ){ 
      $result->{ia} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('scannerGetList', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('scannerGetList', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scannerClose {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_scannerClose_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_scannerClose_result->new();
    eval {
      $self->{handler}->scannerClose($args->id);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Hbase::IllegalArgument') ){ 
      $result->{ia} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('scannerClose', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('scannerClose', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getRegionInfo {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_getRegionInfo_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_getRegionInfo_result->new();
    eval {
      $result->{success} = $self->{handler}->getRegionInfo($args->row);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('getRegionInfo', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('getRegionInfo', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_append {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_append_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_append_result->new();
    eval {
      $result->{success} = $self->{handler}->append($args->append);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('append', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('append', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_checkAndPut {
    my ($self, $seqid, $input, $output) = @_;
    my $args = Hbase::Hbase_checkAndPut_args->new();
    $args->read($input);
    $input->readMessageEnd();
    my $result = Hbase::Hbase_checkAndPut_result->new();
    eval {
      $result->{success} = $self->{handler}->checkAndPut($args->tableName, $args->row, $args->column, $args->value, $args->mput, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
      $@ = undef;
        }; if( UNIVERSAL::isa($@,'Hbase::IllegalArgument') ){ 
      $result->{ia} = $@;
      $@ = undef;
    }
    if ($@) {
      $@ =~ s/^\s+|\s+$//g;
      my $err = Thrift::TApplicationException->new("Unexpected Exception: " . $@, Thrift::TApplicationException::INTERNAL_ERROR);
      $output->writeMessageBegin('checkAndPut', Thrift::TMessageType::EXCEPTION, $seqid);
      $err->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      $@ = undef;
      return;
    }
    $output->writeMessageBegin('checkAndPut', Thrift::TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

1;
